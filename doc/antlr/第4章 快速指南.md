## 第四章 快速指南
>本章分为四个主题，分别展示了ANTLR的不同特性。在阅读本章时，最好下载本书的样例代码同步学习。这样，你就能习惯于编写语法文件和构建ANTLR程序。
>记住，遍布本章的代码片段并不是完整的文件，我们侧重代码的关键部分。

### 4.1 匹配算数表达式的语言
>我们的第一个语法用于构建一个简单的计算器，其对算术表达式的处理具体有十分重要的意义，因为它们太常见了。为了简单起见，我们只允许基本的算术操作符（加减乘除）
>圆括号、整数以及常量出现。我们的算术表达式限制浮点数的使用，只允许整数出现。

* tour/Expr.g4
```g4
grammar Expr;
prog: stat+;
stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;
expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;
ID  : [a-zA-Z]+;						//匹配标识符
INT : [0-9]+;							//匹配整数
NEWLINE: '\r'? '\n'?' \r\n';					//高数语法分析器一个新行的开始（即语句终止状态）
WS  : [ \t]+ ->skip;						//丢弃空白字符
```

* 下面的main程序展示了一些必要的代码，这些代码首先新建出所需的所有对象，然后针对prog规则启动我们的“表达式语言”语法分析器。
```java
public class ExprJoyRideTest {
    public static void main(String[] args) throws IOException{
        String inputFile = null;
        InputStream is;
        if(inputFile==null){
            inputFile = "t.expr";
        }
        is = ExprJoyRideTest.class.getClassLoader().getResourceAsStream(inputFile);
        CharStream inputStream = CharStreams.fromStream(is);
        ExprLexer lexer = new ExprLexer(inputStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ExprParser parser = new ExprParser(tokens);
        ParseTree tree = parser.prog();		//从prog规则开始进行语法分析
        System.out.println(tree.toStringTree(parser));		//以文本形式打印树
    }
}
```

#### 语法导入
>如何将大型语法维持在可控范围内？一个好主意是，将非常大的语法拆分成逻辑单元，正如我们在软件开发中所做的那样。

* tour/CommonLexerRules.g4
```g4
lexer grammar CommonLexerRules;	//注意区别，是“lexer grammar”

ID :[a-zA-Z]+;		//匹配标识符
INT:[0-9]+;		//匹配整数
NEWLINE:'\r'? '\n';	//告诉语法分析器一个新行的开始（即语句终止标志）
WS : [ \t]+ -> skip;	//丢弃空白字符
```
>现在我们可以将原先的语法中的那些词法规则替换为一个import语句了。
* tour/LibExpr.g4
```g4
grammar LibExpr;		// 为了和原先的语法区分开，进行了重命名
import CommonLexerRules;	//引入CommonLexerRules.g4 中的全部规则
/** 起始规则，语法分析的起点 */
prog:stat+;

stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;

expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;
```

#### 处理有错误的输入
>ANTLR的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕捉识别过程中的异常，甚至改变基本的异常处理策略。我们将在第九章中涉及这些内容。


### 4.2 利用访问器构建一个计时器



### 4.3 利用监听器构建一个计时器



### 4.4 定制语法分析过程



### 4.5 神奇的词法分析特性