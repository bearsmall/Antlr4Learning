## 第四章 快速指南
>本章分为四个主题，分别展示了ANTLR的不同特性。在阅读本章时，最好下载本书的样例代码同步学习。这样，你就能习惯于编写语法文件和构建ANTLR程序。
>记住，遍布本章的代码片段并不是完整的文件，我们侧重代码的关键部分。

### 4.1 匹配算数表达式的语言
>我们的第一个语法用于构建一个简单的计算器，其对算术表达式的处理具体有十分重要的意义，因为它们太常见了。为了简单起见，我们只允许基本的算术操作符（加减乘除）
>圆括号、整数以及常量出现。我们的算术表达式限制浮点数的使用，只允许整数出现。

* tour/Expr.g4
```g4
grammar Expr;
prog: stat+;
stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;
expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;
ID  : [a-zA-Z]+;						//匹配标识符
INT : [0-9]+;							//匹配整数
NEWLINE: '\r'? '\n'?' \r\n';					//高数语法分析器一个新行的开始（即语句终止状态）
WS  : [ \t]+ ->skip;						//丢弃空白字符
```

* 下面的main程序展示了一些必要的代码，这些代码首先新建出所需的所有对象，然后针对prog规则启动我们的“表达式语言”语法分析器。
```java
public class ExprJoyRideTest {
    public static void main(String[] args) throws IOException{
        String inputFile = null;
        InputStream is;
        if(inputFile==null){
            inputFile = "t.expr";
        }
        is = ExprJoyRideTest.class.getClassLoader().getResourceAsStream(inputFile);
        CharStream inputStream = CharStreams.fromStream(is);
        ExprLexer lexer = new ExprLexer(inputStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ExprParser parser = new ExprParser(tokens);
        ParseTree tree = parser.prog();		//从prog规则开始进行语法分析
        System.out.println(tree.toStringTree(parser));		//以文本形式打印树
    }
}
```

#### 语法导入
>如何将大型语法维持在可控范围内？一个好主意是，将非常大的语法拆分成逻辑单元，正如我们在软件开发中所做的那样。

* tour/CommonLexerRules.g4
```g4
lexer grammar CommonLexerRules;	//注意区别，是“lexer grammar”

ID :[a-zA-Z]+;		//匹配标识符
INT:[0-9]+;		//匹配整数
NEWLINE:'\r'? '\n';	//告诉语法分析器一个新行的开始（即语句终止标志）
WS : [ \t]+ -> skip;	//丢弃空白字符
```
>现在我们可以将原先的语法中的那些词法规则替换为一个import语句了。
* tour/LibExpr.g4
```g4
grammar LibExpr;		// 为了和原先的语法区分开，进行了重命名
import CommonLexerRules;	//引入CommonLexerRules.g4 中的全部规则
/** 起始规则，语法分析的起点 */
prog:stat+;

stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;

expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;
```

#### 处理有错误的输入
>ANTLR的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕捉识别过程中的异常，甚至改变基本的异常处理策略。我们将在第九章中涉及这些内容。


### 4.2 利用访问器构建一个计时器
>在开始之前，我们需要先对语法做少量的修改。首先，我们需要给备选的分支加上标签（这些标签可以是任意标识符，只要他们不与规则名冲突）。如果备选分支
>上面没有标签，ANTLR就只为每条规则生成一个方法（第七章使用了一个相似的语法对访问器机制进行了详细讲解）。在本例中，我们希望每个备选分支都有不同的访问器
>方法，这样我们就可以对每种输入都获得一个不同的“事件”。在我们的新语法LabeledExpr中，标签以#开头，放置在一个备选分支的右侧。

* tour/CommonLexerRules.g4
```g4
lexer grammar CommonLexerRules;

ID :[a-zA-Z]+;
INT:[0-9]+;
NEWLINE:'\r'? '\n';
WS : [ \t]+ -> skip;
```
* tour/LabeledExpr.g4
```g4
grammar LabeledExpr;
import CommonLexerRules;

prog:  stat+;

stat: expr NEWLINE              # printExpr
    | ID '=' expr NEWLINE       # assign
    | NEWLINE                   # blank
    ;

expr: expr op=('*'|'/') expr    # MulDiv
    | expr op=('+'|'-') expr    # AddSub
    | INT                       # int
    | ID                        # id
    | '(' expr ')'              # parens
    ;

MUL: '*';
DIV: '/';
ADD: '+';
SUB: '-';
```

>完成这份增强版语法之后，我们就可以开始编码实现我们的计算器了。可以看到Calc.java的main()方法几乎和之前的ExprJoyRide.java完全一样。
>差别之一是，在新程序中，我们创建的词法分析器对象和语法分析器对象是基于语法LabeledExpr的，而非Expr。

* tour/Calc.java
```java
public class CalcTest {
    @Test
    public void test() throws IOException{
        String inputFile = "t.expr";
        InputStream is = System.in;
        if(inputFile!=null){
            is = CalcTest.class.getClassLoader().getResourceAsStream(inputFile);
        }
        ANTLRInputStream inputStream = new ANTLRInputStream(is);
        LabeledExprLexer lexer = new LabeledExprLexer(inputStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        LabeledExprParser parser = new LabeledExprParser(tokens);
        ParseTree tree = parser.prog();

        EvalVisitor eval = new EvalVisitor();
        eval.visit(tree);
    }
}
```

>下面看看EvalVisitor访问器如何实现的。

* 首先，ANTLR自动生成生成了一个访问器接口，并为其中每个带标签的备选分支生成一个放方法。
```java
public interface LabelExprVisitor<T>{
    T visitId(LabeledExprParser.IdContext ctx);             # 来自标签 id
    T visitAssign(LabeledExprParser.AssignContext ctx);     # 来自标签 id
    T visitMulDiv(LabeledExprParser.MulDivContext ctx);     # 来自标签 id
}
```
> 该接口使用了Java的泛型定义，参数化的类型是visit方法的返回值的类型。这允许我们的实现类使用自定义的返回值类型，以适应不同的场合。

>其次，ANTLR生成了该访问器的一个默认实现类LabeledExprBaseVisitor供我们使用。考虑我们的实际情况，表达式的计算结果都是整数，因此我们
>的EvalVisitor类应该继承LabeledExprBaseVisitor<Integer>类。为最终完成计算器的实现，我们覆盖了访问器中表达式和赋值语句规则对应的方法。

```java
public class EvalVisitor extends LabeledExprBaseVisitor<Integer> {

    Map<String,Integer> memory = new HashMap<>();

    @Override
    public Integer visitAssign(LabeledExprParser.AssignContext ctx) {
        String id = ctx.ID().getText();
        int value = visit(ctx.expr());
        memory.put(id,value);
        return value;
    }

    @Override
    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) {
        Integer value = visit(ctx.expr());
        System.out.println(value);
        return 0;
    }

    @Override
    public Integer visitInt(LabeledExprParser.IntContext ctx) {
        return Integer.valueOf(ctx.INT().getText());
    }

    @Override
    public Integer visitId(LabeledExprParser.IdContext ctx) {
        String id = ctx.getText();
        if(memory.containsKey(id))
            return memory.get(id);
        return 0;
    }

    @Override
    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));
        if(ctx.op.getType()==LabeledExprParser.MUL)
            return left*right;
        return left/right;
    }

    @Override
    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));
        if(ctx.op.getType()==LabeledExprParser.ADD)
            return left+right;
        return left-right;
    }

    @Override
    public Integer visitParens(LabeledExprParser.ParensContext ctx) {
        return visit(ctx.expr());
    }
}
```

>在继续学习之前，你可能需要花费一点功夫，给我们的“表达式语言”增加一个clear语句。这是一个锻炼你的好机会，让你亲自动手进行实际操作。
>而又无须深入了解全部细节。clear命令将计算器的“内存”清空（即EvalVisitor的memory成员），你需要在stat规则中增加一个新的备选分支来识别它。
>使用#clear来给这个新的备选分支加上标签，然后对修改后的语法运行ANTLR命令，获得生成的访问器接口。然后，为了能在接收clear命令的时候做出响应，
>你需要实现visitClear()方法，最后，按照之前的步骤编译并运行Calc。
### 4.3 利用监听器构建一个计时器



### 4.4 定制语法分析过程



### 4.5 神奇的词法分析特性