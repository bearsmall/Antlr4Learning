## 第二章 纵观全局

>在上一章中，我们安装了ANTLR，了解了如何构建和运行一个简单的示例语法。在本章中，我们
>将壮观全局，学习语言类应用程序相关的重要过程、术语和数据结构。随着学习的深入，我们将
>认识一些关键的ANTLR对象，并简单了解ANTLR在背后帮助我们完成的工作。

### 2.1 从ANTLR源语言开始
>识别语言的程序称为语法分析器（parser）或者句法分析器（syntax analyzer）。句法是指约束语言
>中的各个组成部分之间关系的规则，在本书中，我们会通过ANTLR语法来指定语法的句法。语法（grammar）
>是一系列规则的集合，每条规则表述出一种词汇结构。ANTLR工具能够将其转换为如同经验丰富的开发者手工
>构建一般的语法分析器。ANTLR语法本身又遵循了一种专门用来描述其他语言的语法，我们称之为ANTLR元语言（ANTLR's meta-language）。

* 字符流-》词法分析器-》词法符号流-》语法分析器-》语法树

### 2.2 实现一个语法分析器

>ANTLR工具依据类似于我们之前看到的assign的语法规则，产生一个递归下降的语法分析器（recursive-descent parser)。
>递归下降的语法分析器实际上是若干递归方法的集合，每个方法对应一条规则。下降的过程就是从语法分析树的根结点开始，朝着叶节点（词法符号）
>进行解析的过程。首先调用的规则，即语义符号的起点，就会成为语法分析树的根结点。

* 根据assign规则生成的方法（稍微经过格式整理），用于展示递归下降语法分析器的细节：
```g4
//assign : ID '=' expr ';' ;

void assign(){          //根据assign规则生成的方法
    match(ID);          //将当前的输入符号和ID相比较，然后将其消费掉
    match('=');
    expr();             //通过调用当前方法expr()来匹配一个表达式
    match(';');
}
```
>递归下降语法分析器最神奇的地方在于，通过方法stat()、assign()和expr()的调用描绘出的调用路线图映射到了语法分析树的节点上。
>调用match()对应了语法分析树的叶子节点。在手工构造的语法分析器中，我们需要在每条规则对应的方法的开始位置插入“增加一个新的子树根节点”
>这样的操作，在match()方法中插入“增加一个新的叶子节点”这样的操作。

* 词汇符号除了顺序结构外还可以拥有更多的备选分支
```g4
/**从当前输入位置开始，匹配多种语句 */
stat: assign        // 第一个备选分支（'\' 符号是备选分支的分隔符）
    | ifstat        // 第二个备选分支
    | whilestat
    ...
    ;
```
>stat语法规则对应的switch多条件分支语句
```g4
void stat(){
    switch (《当前输入的词法符号》){
        CASE ID :   assign();   break;
        CASE IF :   ifstat();   break;  //IF是if关键字的词法符号类型
        CASE WHILE: whilestat();break;
        ...
        default :   《 抛出无可选方案的异常 》
    }
}
```

> 为了测试一个语句是不是合法的，我们将这个语句中的单词和迷宫的地板上的单词比较，然后沿着这个语句的单词所描述的路径在迷宫中
> 前进。如果我们能够通过这个语句中的单词序列指定的路径已将到达，那么这个语句就是合法的。

### 2.3 你再也不能往核反应堆多加水了

> 歧义性语句是指存在不止一种语义的语句，换句话说，歧义性语句中的单词序列能够匹配多种语法结构。本节中标题“你再也不能往核反应堆多加水了”这句话让人不确定，是已经无法往核反应堆多加水还是不应该往核反应堆多加水。
* 明显的歧义
```g4
stat: ID '=' expr ';'   //匹配一个赋值语句
    | ID '=' expr ';'   //糟糕！重复了前一个备选的分支！
    ;
```
* 微妙的歧义
```g4
stat: expr ';'          //表达式语句，也可以匹配“f();”
    | ID '(' ')' ';'    //函数调用
    ;

expr: ID '(' ')'
    | INT
    ;
```
> 这里有两种方式都可以匹配到f()；
> ANTLR 解决歧义问题的方法是：选择所有匹配的备选分支中的第一条。在上面的例子中，ANTLR将会选择左边的语法分析树作为输入文本“f();”的语义解释。
* 更多有关词法分析中歧义性的信息，请参阅5.5节中“匹配标识符”部分。
* 有时候，一门语言的语法本身就存在歧义性，无论如何修改语法也不能改变这一点。例如常见的数学表达式 1 + 2 * 3 可以用两种方式解释，一种是自左向右地处理（Smalltalk就是这么做的），
另外一种是像绝大多数编程语言一样，按照优先级来处理。我们将在5.4节中学习如何隐式地指定表达式中的运算符优先级。
* 经典的C语言向我们展示了另一种歧义，我们可以通过包含标识符定义的上下文信息来解决这样的歧义问题。例如，对于代码片段“i * j;”，从句法角度看，它像是一个表达式，但是实际上它的实际含义，
或者说语义，依赖于i是一个类型还是一个变量。如果i是一个类型的名字，那么这段代码就不是一个表达式，而是一个指向类型i的指针变量j的声明。我们将在第11章中解决这样的歧义问题。

### 2.4 使用语法分析树来构建语言类应用程序

>词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器即根据这些信息来检查语法的正确性并构建一颗语法分析树。这个过程对应的ANTLR类是CharStream、Lexer、Token、Parser，以及ParseTree。
>连接词法分析器和语法分析器的“管道”就是TokenStream。

>ParseTree的子类RuleNode和TerminalNode，两者分别是子树的根节点和叶子节点。RuleNode有一些令人熟悉的方法，例如getChild()和getParent()，但是，对于一个特定的语法，RuleNode并不是确定不变的。
>为了更好地支持对特定节点的元素的访问，ANTLR会对每条规则生成一个RuleNode的子类。如StatContext、AssignContext以及ExprContext。


### 2.5 语法分析树监听器和访问器

> ANTLR的运行库提供了两种遍历树的机制。默认情况下，ANTLR使用内建的遍历器访问生成的语法分析树，并为每个遍历时可能触发的事件生成一个语法分析树监听器接口（parse-tree listener interface）。
> 监听器非常类似于XML解析器生成的SAX文档对象。SAX监听器接收类似startDocument()和endDocument()的事件通知。一个监听器的方法实际上就是回调函数，正如我们在图形界面程序中响应复选框点击事件一样。
> 除了监听器的方式，我们还将介绍一种遍历语法树分析树的方式：访问者模式（visitor pattern）。

* 语法分析树监听器
>为了将遍历树时触发的事件转化为监听器的调用，ANTLR运行库提供了ParseTree-Walker类。我们可以自行实现ParseTreeListener接口，在其中填充自己的逻辑代码（通常是调用程序的其他部分），从而构建出我们自己的语言类应用程序。

* 语法分析树访问器
>有时候我们希望控制遍历语法树的过程，通过显示的方式调用来访问子节点。在命令行中加入-visitor选项可以指示ANTLR为一个语法生成访问器接口（visitor interface），语法中的每条规则对应接口中的一个visit方法。

* 递归下降的语法分析器
>这是自顶向下的语法分析器的一种实现，每条规则都对应语法分析器中的一个函数。

* 前向预测
>语法分析器使用前向预测来进行决策，具体方法是：将输入的符号与每条备选分支的起始符号进行比较。