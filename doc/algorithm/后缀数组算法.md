# 后缀数组基础

### 概念

* 后缀数组：
>后缀数组 SA 是一个一维数组，它保存 1..n 的某个排列 SA[1]，SA[2]，……，SA[n]，并且保证 Suffix(SA[i]) < Suffix(SA[i+1])，1≤i<n。
也就是将 S 的 n 个后缀从小到大进行排序之后把排好序的后缀的开头位置顺次放入 SA 中。

* 名次数组：
>名次数组 Rank\[i\]保存的是 Suffix(i)在所有后缀中从小到大排列的“名次”。

* 后缀数组和名次数组的联系
>简单的说，后缀数组是“排第几的是谁？”，名次数组是“你排第几？”。容易看出，后缀数组和名次数组为互逆运算。
    - sa[rank[i]] = i
    - rank[sa[i]] = i
例如如下序列
S = aabaaaab

|下标     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---------|---|---|---|---|---|---|---|---|
|  S      | a | a | b | a | a | a | a | b |
|Rank     | 4 | 6 | 8 | 1 | 2 | 3 | 5 | 7 |
|SA\[1\]=4| a | a | a | a | b |   |   |   |
|SA\[2\]=5| a | a | a | b |   |   |   |   |
|SA\[3\]=6| a | a | b |   |   |   |   |   |
|SA\[4\]=1| a | a | b | a | a | a | a | b |
|SA\[5\]=7| a | b |   |   |   |   |   |   |
|SA\[6\]=2| a | b | a | a | a | a | b |   |
|SA\[7\]=8| b |   |   |   |   |   |   |   |
|SA\[8\]=3| b | a | a | a | a | b |   |   |

* Height[]数组及其高效计算
>还是先看定义：height[i] = LCP(sa[i], sa[i-1]) 【记为：height[i] = LCP(i, i-1)】【 即排名第i和相邻的排名第i-1第两个后缀的最长公共前缀长度】

    - 对于height[]数组的计算，我们并不能顺序递推。需要充分利用字符串之间的联系，改变他们的计算顺序。所以，我们定义h[i]:
    h[i] = height[rank[i]]，同样的，height[i] = h[sa[i]];
    即从下标i开头的那个后缀suffix(i)与在sa排名中排在它前一位的后缀的最长公共前缀长度。不难得出h[i]的重要性质：
    h[i] >= h[i-1] - 1
    - 证明：
        - 首先，明确一个基本事实：对于任意的i<=j<k，有LCP(j,k) >= LCP(i,k)。
        （直观上理解相对于同一个后缀，与他排得越近的后缀的最长公共前缀一定更长）
        1、若h[i-1]<=1,则h[i]>=0>=h[i-1]-1显然成立。
        2、若h[i-1]>1，带入定义式，即height[rank[i-1]]>1,又因为height[1]=0,所以
        rank[i-1]>1。为了简单起见，令j=i-1,k=sa[rank[i-1]-1]。则suffix(k)>suffix(j)。
        因为h[i-1]>1，所以LCP(rank[k+1],rank[i])=h[i-1]-1
        又rank[k+1]<rank[i],所以rank[i]-1>=rank[k+1]。利用开头那个引理，
        h[i] = LCP(rank[i]-1,rank[i])>=LCP(rank[k+1],rank[i])=h[i-1]-1
        综上，有h[i]>=h[i-1]-1。
### 规律、推论

1. 在求出名次数组后，可以仅用 O(1)的时间比较任意两个后缀的大小。在求出后缀数组或名次数组中的其中一个以后，便可以用 O(n)的时间求出另外一个。


### 结论、分析
>倍增算法的时间复杂度比较容易分析。每次基数排序的时间复杂度为 O(n)，排序的次数决定于最长公共子串的长度，最坏情况下，排序次数为 logn 次，所以总的时间复杂度为 O(nlogn)。


















# [诱导排序与SA-IS算法](https://riteme.site/blog/2016-6-19/sais.html)

* 【简写】
    - 1. LMS
    > Left Most S-Type（最左S形）

* 【定义】
    - 1. LCP(A,B)
    > 表示A和B对最长公共前缀长度，即两者所有相同对前缀中最长对一个长度
    - 2. 后缀类型：S-形后缀、L-形后缀、*-形后缀
    > S-形后缀：suffix(S,i)<suffix(S,i+1)
    > L-形后缀：suffix(S,i)>suffix(S,i+1)
    > *-形后缀：一连串的 S 型中最靠左的一个，后缀#始终是 *-型的
    - 3. LMS 字符
    >  对于每一个 *-型所对应上的字符，我们称为 LMS 字符
    - 3. LMS子串
    > 位置相邻的两个 LMS 字符中间(包括这两个字符)所构成的子串，称为LMS子串
    
* 【结论 or 引理】  
    - 我们可以在 O(|S|) 的时间内，推出整个 t 数组。
    - （后缀数组指导排序）对于两个后缀A和B，如果A[0]=B[0]且A是S型，B是L型，则A>B。
    - (原串折半) 一个字符串中 LMS 子串的数量不超过[|S|/2]
    - 一个字符串的所有 LMS 子串的长度之和为 O(|S|)
    > ？？
    
    
    
          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
    S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
    t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
                *           *           *                 *
   SA[i]: 16            10  6  2
    新名称       2           2           1                 0
    S1:   2 2 1 0
                0   1   2   3
    position    2   6   10  16
    
        bucket  lbucket sbucket
    a   0       0       0
    b   0       0       0
    c   0       0       0
    d   0       0       0
    e   0       0       0
    f   0       0       0
    g   0       0       0
    h   0       0       0
    i   8       0       7---
    j   8       8       7
    k   8       8       7
    l   8       8       7
    m   10      8       7
    n   10      10      9
    o   10      10      9
    p   12      10      11
    q   12      12      11
    r   12      12      11
    s   16      12      15
    t   16      16      15
    u   16      16      15
    v   16      16      15
    w   16      16      15
    x   16      16      15
    y   16      16      15
    z   16      16      15
    #           16      15
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    