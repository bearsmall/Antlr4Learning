/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=CPPAST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.bupt.cmp.ast;

import com.bupt.cmp.ast.java.Token;

public class SimpleNodeJava implements Node, Comparable<SimpleNodeJava> {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected int nodenum;
  protected int mark = 0;
  protected long hashvalue;
  protected Token firstToken;
  protected Token lastToken;

	public void setNodeNum(int nodenum) {
		this.nodenum = nodenum;
	}

	public void addNodeNum(int add) {
		this.nodenum += add;
	}

	public int getNodeNum() {
		return this.nodenum;
	}

	public void setHashValue(long hashvalue) {
		this.hashvalue = hashvalue;
	}
	public void addHashValue(long add) {
		this.hashvalue += add;
	}

	public long getHashValue() {
		return this.hashvalue;
	}

	public void setMark() {
		this.mark = 1;
	}

	public int getMark() {
		return this.mark;
	}

	/*
	 * 以下为恢复mark值的函数
	 */
	public void reMark() {
		this.mark = 0;
	}

	@Override
	public int compareTo(SimpleNodeJava node) {
		if (this.nodenum > node.nodenum) {
			return -1;
		} else if (this.nodenum < node.nodenum) {
			return 1;
		} else {
			if (this.hashvalue > node.hashvalue) {
				return -1;
			} else if (this.hashvalue < node.hashvalue) {
				return 1;
			} else {
				return 0;
			}
		}
	}

	public int getId() {
		return id;
	}

	public SimpleNodeJava(int i) {
		id = i;
	}


  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { 
  		parent = n; 
		}
	public Node jjtGetParent() {
		return parent;
	}

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

	public void jjtSetValue(Object value) {
		this.value = value;
	}

	public Object jjtGetValue() {
		return value;
	}

	public Token jjtGetFirstToken() {
		return firstToken;
	}
	public void jjtSetFirstToken(Token token) {
		this.firstToken = token;
	}
	public Token jjtGetLastToken() {
		return lastToken;
	}
	public void jjtSetLastToken(Token token) {
		this.lastToken = token;
	}
	
	/*
	 * You can override these two methods in subclasses of SimpleNode to
	 * customize the way the node appears when the tree is dumped. If your
	 * output uses more than one line you should override toString(String),
	 * otherwise overriding toString() is probably all you need to do.
	 */

	public String toString() {
		return "SimpleNode(" + nodenum + ", " + hashvalue + ")";
	}
  //public String toString() { return CPPTreeParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) {
		return prefix + toString();
	}

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
//    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNodeJava n = (SimpleNodeJava)children[i];
        if (n != null) {
             n.dump(prefix + " ");
        }
      }
    }
  }
}

