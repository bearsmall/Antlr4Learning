options
{
  //此选项将代码中的u转义符转换成对应的unicode字符，为了避免出错，先加上此选项，日后可以去掉，并改用预处理的方式实现
  JAVA_UNICODE_ESCAPE = true;
  //此选项允许代码中有中文，如果JAVA_UNICODE_ESCAPE设为false，则应该加上该选项
  //UNICODE_INPUT = true;
  //此选项使可以new出任意多个Parser对象
  STATIC = false;
  //不报告错误，可以提高效率
  ERROR_REPORTING = false;
  //自定义工厂类
  //TOKEN_FACTORY = "TokenFactory";
  //缓存token，可以提高效率，但因此不适合交互式使用
  CACHE_TOKENS = true;
  //记录节点首尾TOKEN
  TRACK_TOKENS = true;
  JDK_VERSION = "1.5";
  NODE_CLASS = "CPPSimpleNode";
  NODE_PREFIX = "CPPAST";
  //允许生成token的节点类
  //MULTI = true;
  //NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(CPPTreeParser)
package examiner.ast.cpp;
import java.io.*;
import java.util.*;
import examiner.common.*;
import examiner.pre.TreeProcess;
import examiner.ast.Node;
import examiner.ast.SimpleNode;
import examiner.codefile.DefaultCodeFile;

public final class CPPTreeParser
{
  /**
	 * 运行解析器
	 * 
	 * @param cf
	 * @return
	 */
  static String linshitest;
  public static boolean GetCPPGrammarTree(DefaultCodeFile cf) throws ParseException
  {
    if (cf.getText() == "")
    {
      return false;
    }
    // 解析
    linshitest=cf.getName();
    CPPTreeParser parser;
    parser = new CPPTreeParser(new StringReader(cf.getText()));
    SimpleNode root = parser.translation_unit();
    //将语法树转换为数组，保存在cf中
    new TreeProcess().convertTreeToArrays(root, cf);
    return true;
  }

  /**
	 * A symbol table manager object. Currently only types are recorded for
	 * doing semantic predicates for parsing.
	 */
  public static SymtabManager sym;

  /*
	 * Methods used in semantics predicates.
	 */
  /**
	 * Reads a fully qualified name (since it is used during lookahead, we
	 * cannot use token. We have to explicitly use getToken).
	 */
  public String GetFullyScopedName() /* throws ParseException */
  {
    Token t = getToken(1);
    if (t.kind != ID && t.kind != SCOPE) return null;
    StringBuffer s = new StringBuffer();
    int i;
    if (t.kind != SCOPE)
    {
      s.append(t.image);
      t = getToken(2);
      i = 3;
    }
    else i = 2;
    while (t.kind == SCOPE)
    {
      s.append(t.image);
      s.append((t = getToken(i++)).image);
      t = getToken(i++);
    }
    return s.toString();
  }

  /**
	 * This method first tries to read a sequence of tokens of the form ("::")?
	 * <ID> ("::" <ID>)* and if it succeeds then asks the symbol table manager
	 * if this is the name of a constructor.
	 */
  public boolean IsCtor() /* throws ParseException */
  {
    return sym.IsCtor(GetFullyScopedName());
  }
}

PARSER_END(CPPTreeParser)
TOKEN :/*for #ifdef...else...endif*/
{
  < __TRY : "__try">
| < __ASM : "__asm">
| < __EXCEPT : "__except">
| < __FINALLY : "__finally">
| < __LEAVE : "__leave">
}
SKIP :
{
  " "
| "\t"
| "\r\n"
| "\n"
| "//" : IN_LINE_COMMENT
| "#ifdef" : IN_LINE_COMMENT
| "/*" : IN_COMMENT
| "#else" : ELSE_STATEMENT
| "#" : PREPROCESSOR_OUTPUT
}


< IN_LINE_COMMENT >
SKIP :
{
  "\n" : DEFAULT
}

< IN_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< IN_COMMENT >
SKIP :
{
  "*/" : DEFAULT
}

< IN_COMMENT >
MORE :
{
  < ~[ ] >
}
< ELSE_STATEMENT>
SKIP :
{
  "#endif" : DEFAULT
}
< ELSE_STATEMENT>
MORE :
{
  < ~[ ] >
}
< PREPROCESSOR_OUTPUT >
SKIP :
{
  "\n" : DEFAULT
}

< PREPROCESSOR_OUTPUT >
MORE :
{
  "\\\n"
| "\\\r\n"
| < ~[ ] >
}

TOKEN :
{
  < LCURLYBRACE : "{" >
| < RCURLYBRACE : "}" >
| < LSQUAREBRACKET : "[" >
| < RSQUAREBRACKET : "]" >
| < LPARENTHESIS : "(" >
| < RPARENTHESIS : ")" >
| < SCOPE :
    (
      "::~"
    | "::"
    ) >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < QUESTIONMARK : "?" >
| < ELLIPSIS : "..." >
| < ASSIGNEQUAL : "=" >
| < TIMESEQUAL : "*=" >
| < DIVIDEEQUAL : "/=" >
| < MODEQUAL : "%=" >
| < PLUSEQUAL : "+=" >
| < MINUSEQUAL : "-=" >
| < SHIFTLEFTEQUAL : "<<=" >
| < SHIFTRIGHTEQUAL : ">>=" >
| < BITWISEANDEQUAL : "&=" >
| < BITWISEXOREQUAL : "^=" >
| < BITWISEOREQUAL : "|=" >
| < OR_OP : "||" >
| < AND_OP : "&&" >
| < BITWISEOR : "|" >
| < BITWISEXOR : "^" >
| < AMPERSAND : "&" >
| < EQUAL : "==" >
| < NOTEQUAL : "!=" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < LESSTHANOREQUALTO : "<=" >
| < GREATERTHANOREQUALTO : ">=" >
| < SHIFTLEFT : "<<" >
| < SHIFTRIGHT : ">>" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < DIVIDE : "/" >
| < MOD : "%" >
| < PLUSPLUS : "++" >
| < MINUSMINUS : "--" >
| < TILDE : "~" >
| < NOT_OP : "!" >
| < DOT : "." >
| < POINTERTO : "->" >
| < DOTSTAR : ".*" >
| < ARROWSTAR : "->*" >
| < AND : "and" >
| < AND_EQ : "and_eq" >
| < ASM : "asm" >
| < AUTO : "auto" >
| < BITAND : "bitand" >
| < BITOR : "bitor" >
| < BOOL : "bool" >
| < BREAK : "break" >
| < CASE : "case" >
| < CATCH : "catch" >
| < CHAR : "char" >
| < CLASS : "class" >
| < COMPL : "compl" >
| < CONST : "const" >
| < CONST_CAST : "const_cast" >
| < CONTINUE : "continue" >
| < _DEFAULT : "default" >
| < DELETE : "delete" >
| < DO : "do" >
| < DOUBLE : "double" >
| < DYNAMIC_CAST : "dynamic_cast" >
| < ELSE : "else" >
| < ENUM : "enum" >
| < EXPLICIT : "explicit" >
| < EXPORT : "export" >
| < EXTERN : "extern" >
| < FALSE : "false" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FRIEND : "friend" >
| < GOTO : "goto" >
| < IF : "if" >
| < INLINE : "inline" >
| < INT : "int" >
| < LONG : "long" >
| < mutable : "mutable" >
| < NAMESPACE : "namespace" >
| < NEW : "new" >
| < NOT : "not" >
| < NOT_EQ : "not_eq" >
| < OPERATOR : "operator" >
| < OR : "or " >
| < OR_EQ : "or_eq " >
| < PRIVATE : "private" >
| < PROTECTED : "protected" >
| < PUBLIC : "public" >
| < REGISTER : "register" >
| < REINTERPRET : "reinterpret_cast" >
| < RETURN : "return" >
| < SHORT : "short" >
| < SIGNED : "signed" >
| < SIZEOF : "sizeof" >
| < _STATIC : "static" >
| < STATIC_CAST : "static_cast" >
| < STRUCT : "struct" >
| < SWITCH : "switch" >
| < TEMPLATE : "template" >
| < THIS : "this" >
| < THROW : "throw" >
| < TRUE : "true " >
| < TRY : "try"|"TRY" >
| < TYPEDEF : "typedef" >
| < TYPEID : "typeid" >
| < TYPENAME : "typename" >
| < UNION : "union" >
| < UNSIGNED : "unsigned" >
| < USING : "using" >
| < VIRTUAL : "virtual" >
| < VOID : "void" >
| < VOLATILE : "volatile" >
| < WCHAR_T : "wchar_t" >
| < DWORD : "DWORD" >
| < WORD : "WORD" >
| < BYTE : "BYTE" >
| < WHILE : "while" >
| < XOR : "xor" >
| < XOR_EQ : "xor_eq " >
| < STD : "std">
}
//add std to deal with std::vector...
TOKEN [ IGNORE_CASE ] :
{
  < OCTALINT : "0" ([ "0"-"7" ])* >
| < OCTALLONG : < OCTALINT > "l" >
| < UNSIGNED_OCTALINT : < OCTALINT > "u" >
| < UNSIGNED_OCTALLONG :
    < OCTALINT >
    (
      "ul"
    | "lu"
    ) >
| < DECIMALINT : [ "1"-"9" ] ([ "0"-"9" ])* >
| < DECIMALLONG : < DECIMALINT > [ "u", "l" ] >
| < UNSIGNED_DECIMALINT : < DECIMALINT > "u" >
| < UNSIGNED_DECIMALLONG :
    < DECIMALINT >
    (
      "ul"
    | "lu"
    ) >
| < HEXADECIMALINT : "0x" ([ "0"-"9", "a"-"f" ])+ >
| < HEXADECIMALLONG : < HEXADECIMALINT > ([ "u", "l" ])? >
| < UNSIGNED_HEXADECIMALINT : < HEXADECIMALINT > "u" >
| < UNSIGNED_HEXADECIMALLONG :
    < HEXADECIMALINT >
    (
      "ul"
    | "lu"
    ) >
| < FLOATONE :
    (
      ([ "0"-"9" ])+ "." ([ "0"-"9" ])*
    | ([ "0"-"9" ])* "." ([ "0"-"9" ])+
    )
    (
      "e" ([ "-", "+" ])? ([ "0"-"9" ])+
    )?
    ([ "f", "l" ])? >
| < FLOATTWO : ([ "0"-"9" ])+ "e" ([ "-", "+" ])? ([ "0"-"9" ])+ ([ "f", "l" ])? >
}

TOKEN :
{
  < CHARACTER :
    ("L")? "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "v", "b", "r", "f", "a", "\\", "?", "'", "\"" ]
        | "0" ([ "0"-"7" ])*
        | [ "1"-"9" ] ([ "0"-"9" ])*
        |
          (
            "0x"
          | "0X"
          )
          ([ "0"-"9", "a"-"f", "A"-"F" ])+
        )
      )
    )*
    "'" >
| < STRING :
    ("L")? "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "v", "b", "r", "f", "a", "\\", "?", "'", "\"", "\n" ]
        | "0" ([ "0"-"7" ])*
        | [ "1"-"9" ] ([ "0"-"9" ])*
        |
          (
            "0x"
          | "0X"
          )
          ([ "0"-"9", "a"-"f", "A"-"F" ])+
        )
      )
    )*
    "\"" >
}

TOKEN :
{
  < ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}

SimpleNode translation_unit() #Root :
{}
{
  {
    sym.OpenScope(null, false);
  }
  (
    LOOKAHEAD(2)
    external_declaration()
  )*
  endfun()
  {
    sym.CloseScope();
    return jjtThis;
  }
}
void endfun() #void:
{
}
{
  < EOF >
}
void external_declaration() #external_declaration :
{
  boolean isTypedef = false;
  System.out.println("external_declaration()");
}
{
  LOOKAHEAD({ getToken(1).kind == __TRY || getToken(1).kind == __ASM || getToken(1).kind == __FINALLY })
  (
    < __TRY >
  | 
    < __ASM >
  | 
    < __FINALLY >
  )
  compound_statement()
| < __EXCEPT >
  (
    {
      while (getToken(1).kind != LCURLYBRACE)
      {
        jj_consume_token(getToken(1).kind);
      }
    }
    compound_statement()
  )
| < __LEAVE > ";"
| 
  LOOKAHEAD(("typedef"
| template_head())? class_head() "{")
  {
    System.out.println("external_declaration() -- > template_head+declaration");
  }
  (
    {
      System.out.println("external_declaration() -- > template_head()");
    }
    template_head()
  )?
  declaration()
| LOOKAHEAD("enum" (t = < ID >)? "{")
  enum_specifier()
  (
    init_declarator_list(false)
  )?
  ";"
| LOOKAHEAD((template_head())? dtor_ctor_decl_spec() dtor_declarator() "{")
  {
    System.out.println("=dtor_definition()=");
  }
  dtor_definition()
| LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
  {
    System.out.println("=dtor_ctor_decl_spec()=");
  }
  ctor_definition()
| LOOKAHEAD((declaration_specifiers())? function_declarator_lookahead())
  {
    System.out.println("=function_definition()=");
  }
  function_definition()
| LOOKAHEAD((scope_override())? "operator")
  {
    System.out.println("=conversion_function_decl_or_def()=");
  }
  conversion_function_decl_or_def()
| template_head()
  (
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
    ctor_definition()
  | LOOKAHEAD((declaration_specifiers())? function_declarator_lookahead())
    function_definition()
  | isTypedef = declaration_specifiers()
    (
      init_declarator_list(isTypedef)
    )?
    ";"
  )
|
  {
    System.out.println("=declaration()=");
  }
  declaration()
| ";"
  {
    System.out.println("The Very Beginning consume ;;;;;;;;;;;;;;;;");
  }
| < USING > < NAMESPACE > < ID > ";"
| LOOKAHEAD(3,((< STD >)< SCOPE >< ID >))
{
  System.out.println("external_declaration() to std::id");
}
Scope_declaration()
}
//deal with std::vector and etc...
void function_definition() #function_definition :
{
  Scope sc = null;
  boolean isTypedef;
  System.out.println("function_definition():"+getToken(1).image+getToken(2).image+getToken(3).image);
}
{
  LOOKAHEAD(3)
  {
    System.out.println("function_definition():"+"case 1");
  }
  isTypedef = declaration_specifiers()
  sc = function_declarator(isTypedef)
  func_decl_def(sc)
|
  {
    System.out.println("function_definition():"+"case 2");
  }
  sc = function_declarator(false)
  func_decl_def(sc)
}

void func_decl_def(Scope sc) #func_decl_def :
{
  boolean closeReqd = false;
  System.out.println("Welcome to func_decl_def");
}
{
  {
    if (closeReqd = (sc != null && sc != sym.GetCurScope()))
    {
      System.out.println("Open a new Scope in func_decl_def");
      sym.OpenScope(sc);
    }
  }
  (
    {
      System.out.println("func_decl_def -- > compound_statement");
    }
    compound_statement() // { balabala }
    {
      System.out.println("func_decl_def -- > compound_statement end");
    }
  | 
    (
    ";"
    )?
    {
      System.out.println("Welcome to func_decl_def, here consume a ; or nothing");
    }
  )
  {
    if (closeReqd)
    {
      System.out.println("Close a new Scope in func_decl_def");
      sym.CloseScope();
    }
  }
}

void linkage_specification() #linkage_specification :
{}
{
  "extern" < STRING >
  (
    "{"
    (
      external_declaration()
    )*
    "}"
    (
      LOOKAHEAD(";")
      ";"
    )?
  | declaration()
  )
}
//protea changed in 1023
void declarationforif() #declarationforif :
{
  boolean isTypedef = false;
}
{
  LOOKAHEAD(3)
  isTypedef = declaration_specifiers()
  (
    {
      System.out.println("======Next step is init_declarator_list()=====");
    }
    init_declarator_list(isTypedef)
  )?
  {
    System.out.println("declaration() : consume a ;");
  }
| 
  LOOKAHEAD(3)
  extern_linkage_specification()
|
  {
    System.out.println("=====Next step is linkage_specification()()=====");
  }
  linkage_specification()
}
void declaration() #declaration :
{
  boolean isTypedef = false;
}
{
  LOOKAHEAD(3)
  isTypedef = declaration_specifiers()
  (
    {
      System.out.println("======Next step is init_declarator_list()=====");
    }
    init_declarator_list(isTypedef)
  )?
  ";"
  {
    System.out.println("declaration() : consume a ;");
  }
| 
  LOOKAHEAD(3)
  extern_linkage_specification()
|
  {
    System.out.println("=====Next step is linkage_specification()()=====");
  }
  linkage_specification()
}
// to deal with extern "C" function_declaration function_definition or ";"
void extern_linkage_specification()#extern_linkage_specification:
{
}
{
  "extern" < STRING >
  (
    extern_builtin_type_specifier()
  | < ID >
  )+
  "("
  {
    while (getToken(1).kind != RPARENTHESIS)
    {
      jj_consume_token(getToken(1).kind);
    }
    System.out.println("the end before \")\"");
  }
  ")"
  //LOOKAHEAD((declaration_specifiers())? function_declarator_lookahead())
  (
    ";"
  | 
    function_definition()
  )
}
/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean type_modifiers() #type_modifiers :
{
  boolean isTypedef = false;
}
{
  (
    isTypedef = storage_class_specifier()
  | type_qualifier()
  | "inline"
  | "virtual"
  | "friend"
  )
  {
    return isTypedef;
  }
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 * protea changed in 1018
 */
boolean declaration_specifiers() #declaration_specifiers :
{
  Token t;
  boolean isTypedef = false, tmp;
  System.out.println("declaration_specifiers:"+getToken(1).image + getToken(2).image + getToken(3).image);
}
{
  ( 
    LOOKAHEAD({ getToken(1).kind == STD })
    (
      {
        System.out.println("there is a kind type named std::<ID>:" + getToken(1).image + getToken(2).image + getToken(3).image);
      }
      < STD > < SCOPE > < ID > ("<" template_argument_list() ">")*
      (
        "*"
      | "&"
      )*
    )
  | 
    (
      LOOKAHEAD(type_modifiers())
      tmp = type_modifiers()
      {
        System.out.println("===declaration_specifiers --> type_modifiers===");
        isTypedef |= tmp;
      }
    )+
    [
      LOOKAHEAD(2)
      (
        LOOKAHEAD(extern_builtin_type_specifier())
        {
          System.out.println("===In extern_builtin_type_specifier() 1_1===");
        }
        extern_builtin_type_specifier()
        (
          LOOKAHEAD(2)
          (
            LOOKAHEAD(extern_builtin_type_specifier())
            {
              System.out.println("===In extern_builtin_type_specifier() 1_2===");
            }
            extern_builtin_type_specifier()
          | LOOKAHEAD(type_modifiers())
            tmp = type_modifiers()
          )
          {
            System.out.println("===extern_builtin_type_specifier --> type_modifiers 1===");
            isTypedef |= tmp;
          }
        )*
      |
        (
          class_specifier()
          {
            System.out.println("===declaration_specifiers --> class_specifier()===");
          }
        | enum_specifier()
          {
            System.out.println("===declaration_specifiers --> enum_specifier()===");
          }
        | qualified_type()
          {
            System.out.println("===declaration_specifiers --> qualified_type()===");
          }
        )
        (
          LOOKAHEAD(2)
          tmp = type_modifiers()
          {
            System.out.println("===last type_modifiers for choose 1===");
            isTypedef |= tmp;
          }
        )*
      )
    ]
  | LOOKAHEAD(extern_builtin_type_specifier())
    {
      System.out.println("===In extern_builtin_type_specifier() 2_1===");
    }
    extern_builtin_type_specifier()
    (
      LOOKAHEAD(2)
      (
        LOOKAHEAD(extern_builtin_type_specifier())
        {
          System.out.println("===In extern_builtin_type_specifier() 2_2===");
        }
        extern_builtin_type_specifier()
      | tmp = type_modifiers()
        {
          System.out.println("===last type_modifiers for choose 2===");
          isTypedef |= tmp;
        }
      )
    )*
  |
    (
      {
        System.out.println("===declaration_specifiers --> class_specifier()===");
      }
      class_specifier()
    | enum_specifier()
      {
        System.out.println("===declaration_specifiers --> enum_specifier()===");
      }
    | qualified_type()
      {
        System.out.println("===declaration_specifiers --> qualified_type()===");
      }
    )
    (
      LOOKAHEAD(2)
      tmp = type_modifiers()
      {
        System.out.println("===last type_modifiers for choose 3===");
        isTypedef |= tmp;
      }
    )*
  )
  {
    return isTypedef;
  }
}

/*
void type_specifier() :
{}
{
    simple_type_specifier()
   |
    class_specifier()
   |
    enum_specifier()
}
*/
void simple_type_specifier() #simple_type_specifier :
{}
{
  (
    extern_builtin_type_specifier()
  | qualified_type()
  )
}

//protea changed in 1017
void scope_override_lookahead() #scope_override_lookahead :
{}
{
  < SCOPE >
| < ID >
  (
    "<" template_argument_list() ">"
  )?
  < SCOPE >
}

//protea changed in 1017 scope
String scope_override() #scope_override :
{
  String name = "";
  Token t;
  System.out.println("scope_override():"+getToken(1).image+"||"+getToken(2).image+"||"+getToken(3).image);
}
{
  (
    (< SCOPE >)
    {
      name += "::";
    }
    (
      LOOKAHEAD(2)
      t = < ID >
      {
        System.out.println("::< ID >=" + t.image);
      }
      (
        {
          System.out.println("1-"+tokenImage [ getToken(1).kind ] + tokenImage [ getToken(2).kind ] + tokenImage [ getToken(3).kind ] + "11< template_argument_list() >");
        }
        "<" template_argument_list() ">"
      )?
      < SCOPE >

    )*
  |
    (
      LOOKAHEAD(2)
      t = < ID >
      {
        System.out.println("::< ID > ="+t.image);
      }
      (
        {
          System.out.println("2-"+tokenImage [ getToken(1).kind ] + tokenImage [ getToken(2).kind ] + tokenImage [ getToken(3).kind ] + "12< template_argument_list() >");
        }
        "<" template_argument_list() ">"
      )?
      {
        System.out.println("here is ::<ID><template_argument_list()>::");
      }
      < SCOPE >
    )+
    {
      System.out.println("In Scope_Override,we get a name:"+name);
    }
  )
  {
    return name;
  }
}


//protea changed in 1023 deal with std::vector and etc
void Scope_declaration() #Scope_declaration:
{
  String name="";
  Token t;
  int consume;
}
{
  (
    <STD>
  )
  < SCOPE > < ID >
  (
    anytoken()
  )*
  < SEMICOLON >
}
String qualified_id() #qualified_id :
{
  String name = "";
  Token t;
  System.out.println("qualified_id()");
}
{
  [
    LOOKAHEAD(scope_override_lookahead())
    {
      System.out.println("qualified_id() -- > ===scope_override===");
    }
    name = scope_override()
  ]
  (
    t = < ID > [ "<" template_argument_list() ">" ]
    {
      System.out.println("===use template_argument_list()===" + name + t.image);
      return name + t.image;
    }
  | "operator" optor()
    {
      System.out.println("===use optor===");
      return "operator";
    }
  )
}

void ptr_to_member() #ptr_to_member :
{}
{
  scope_override() "*"
}

void qualified_type() #qualified_type :
{
  System.out.println("qualified_type() can go to qualified_id()");
}
{
  {
    System.out.println("qualified_type() -- > IsFullyScopedTypeName()");
  }
  LOOKAHEAD({ sym.IsFullyScopedTypeName(GetFullyScopedName()) })  
  qualified_id()
}

void type_qualifier() #type_qualifier :
{}
{
  "const"
| "volatile"
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean storage_class_specifier() #storage_class_specifier :
{}
{
  (
    "auto"
  | "register"
  | "static"
  | "extern"
  )
  {
    return false;
  }
| "typedef"
  {
    return true;
  }
}

void builtin_type_specifier() #builtin_type_specifier :
{}
{
  "void"
| "bool"
| "char"
| "short"
| "int"
| "long"
| "float"
| "double"
| "signed"
| "unsigned"
| "wchar_t"
| "DWORD"
| "WORD"
| "BYTE"
}

//protea changed in 1018
// normal type|<ID> type|(<ID>) <ID>/normal type type| (<ID>):: type| typedef <ID> type
// and int* <ID> type
void extern_builtin_type_specifier() #extern_builtin_type_specifier :
{
  System.out.println("extern_builtin_type_specifier():"+ tokenImage [ getToken(1).kind ]+ "-"+ tokenImage [ getToken(2).kind ]+ "-"+ tokenImage [ getToken(3).kind ]);
}
{
  (
    LOOKAHEAD({ getToken(0).kind == TYPEDEF && getToken(1).kind == ID })
    < ID >
  | LOOKAHEAD({ getToken(1).kind == ID && getToken(2).kind == RPARENTHESIS &&
  (
    getToken(3).kind == ID
    || getToken(3).kind == SCOPE
    || getToken(3).kind == THIS
    || getToken(3).kind == NEW
    || getToken(3).kind == OCTALINT
    || getToken(3).kind == OCTALLONG
    || getToken(3).kind == UNSIGNED_OCTALINT
    || getToken(3).kind == UNSIGNED_OCTALLONG
    || getToken(3).kind == DECIMALINT
    || getToken(3).kind == DECIMALLONG
    || getToken(3).kind == UNSIGNED_DECIMALINT
    || getToken(3).kind == UNSIGNED_DECIMALLONG
    || getToken(3).kind == HEXADECIMALINT
    || getToken(3).kind == HEXADECIMALLONG
    || getToken(3).kind == UNSIGNED_HEXADECIMALINT
    || getToken(3).kind == UNSIGNED_HEXADECIMALLONG
    || getToken(3).kind == FLOATONE
    || getToken(3).kind == FLOATTWO
    || getToken(3).kind == CHARACTER
    || getToken(3).kind == STRING) })
    < ID >
  | 
    LOOKAHEAD({ getToken(1).kind == ID &&
    (
      getToken(2).kind == STAR
      || getToken(2).kind == AMPERSAND
      || getToken(2).kind == ID
      || getToken(2).kind == VOID
      || getToken(2).kind == BOOL
      || getToken(2).kind == CHAR
      || getToken(2).kind == SHORT
      || getToken(2).kind == INT
      || getToken(2).kind == LONG
      || getToken(2).kind == FLOAT
      || getToken(2).kind == DOUBLE
      || getToken(2).kind == SIGNED
      || getToken(2).kind == UNSIGNED
      || getToken(2).kind == WCHAR_T
      || getToken(2).kind == DWORD
      || getToken(2).kind == WORD
      || getToken(2).kind == BYTE
      || getToken(2).kind == CONST
      || getToken(2).kind == VOLATILE
      || getToken(2).kind == INLINE
      || getToken(2).kind == VIRTUAL
      || getToken(2).kind == FRIEND
      || getToken(2).kind == AUTO
      || getToken(2).kind == REGISTER
      || getToken(2).kind == _STATIC
      || getToken(2).kind == EXTERN) })
    < ID >
  | "void"
  | "bool"
  | "char"
  | "short"
  | "int"
  | "long"
  | "float"
  | "double"
  | "signed"
  | "unsigned"
  | "wchar_t"
  | "DWORD"
  | "WORD"
  | "BYTE"
  )
  (
    LOOKAHEAD(< STAR > extern_builtin_type_specifier())
    < STAR >
  )*
}

void init_declarator_list(boolean isTypedef) #init_declarator_list :
{
  System.out.println("init_declarator_list() -- > init_declarator { , init_declarator}");
}
{
  init_declarator(isTypedef)
  (
    "," init_declarator(isTypedef)
  )*
}

void init_declarator(boolean isTypedef) #init_declarator :
{
  String name;
}
{
  name = declarator()
  {
    System.out.println("init_declarator:" + name);
    if (isTypedef) sym.PutTypeName(name);
  }
  (
    {
      System.out.println("init_declarator -- > = initializer()");
    }
    "=" initializer()   
  |
    {
      System.out.println("init_declarator -- >( expression_list() )");
    }
    "(" expression_list() ")"
  )?
}

void class_head() #class_head :
{}
{
  (
    "struct"
  | "union"
  | "class"
  )
  (
    < ID >
    (
      base_clause(null)
    )?
  )?
}

void class_specifier() #class_specifier :
{
  ClassScope sc = null;
  Token t;
  System.out.println("class_specifier()");
}
{
  (
    "struct"
  | "union"
  | "class"
  )
  (
    "{"
    {
      System.out.println("try class_specifier() openScope");
      sym.OpenScope(null, false);
    }
    (
      {
        System.out.println("class_specifier() -- > member_declaration() number 1");
      }
      member_declaration()
    )*
    "}"
    {
      sym.CloseScope();
    }
  | LOOKAHEAD(2)
    t = < ID >
    {
      System.out.println("try class_specifier() openScope after a <ID>");
      sc = (ClassScope) sym.OpenScope(t.image, true);
    }
    (
      base_clause(sc)
    )?
    "{"
    (
      {
        System.out.println("number2 member_declaration() in class_specifier()");
         }
      
      member_declaration()
    )*
    "}"
    {
      sym.CloseScope();
    }
  | t = < ID >
    (
      LOOKAHEAD(2)
      "<" template_argument_list() ">"
    )?
    {
      sym.PutTypeName(t.image);
    }
  )
}

void base_clause(ClassScope scope) #base_clause :
{}
{
  ":" base_specifier(scope)
  (
    "," base_specifier(scope)
  )*
}

void base_specifier(ClassScope scope) #base_specifier :
{
  Token t;
}
{
  (
    "virtual"
    (
      access_specifier()
    )?
  | access_specifier() ("virtual")?
  )?
  (
    LOOKAHEAD(scope_override_lookahead())
    scope_override()
  )?
  t = < ID >
  (
    "<" template_argument_list() ">"
  )?
  {
    scope.AddSuper(sym.GetScope(t.image));
  }
}

void access_specifier() #access_specifier :
{}
{
  "public"
| "protected"
| "private"
}

void member_declaration() #member_declaration :
{
  boolean isTypedef = false;
}
{
  LOOKAHEAD(("typedef")? class_head() "{")
  declaration()
| LOOKAHEAD("enum" (< ID >)? "{")
  enum_specifier()
  (
    member_declarator_list(false)
  )?
  ";"
| LOOKAHEAD("operator")
  conversion_function_decl_or_def()
| LOOKAHEAD(dtor_ctor_decl_spec() dtor_declarator() "{")
  dtor_definition()
| LOOKAHEAD(("inline"
| "virtual")* "~")
  dtor_ctor_decl_spec() simple_dtor_declarator() ";"
| LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
  ctor_definition()
| LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead() ";")
  (
    dtor_ctor_decl_spec() ctor_declarator() ";"
  )
| LOOKAHEAD((declaration_specifiers())? function_declarator_lookahead())
{
  System.out.println("member_declaration() -- > function_definition()");
}
  function_definition()
| LOOKAHEAD(declaration_specifiers())
{
  System.out.println("member_declaration() -- > declaration_specifiers()");
}
  isTypedef = declaration_specifiers()
  (
    member_declarator_list(isTypedef)
  )?
  ";"
| LOOKAHEAD(< ID >)
{
  System.out.println("member_declaration() -- > function_declarator");
}
  function_declarator(false) ";"
| LOOKAHEAD(3)
{
  System.out.println("member_declaration() -- > qualified_id() ;");
}
  qualified_id() ";"
| access_specifier() ":"
| ";"
}

void member_declarator_list(boolean isTypedef) #member_declarator_list :
{}
{
  member_declarator(isTypedef) ("=" < OCTALINT >)?
  (
    "," member_declarator(isTypedef) ("=" < OCTALINT >)?
  )*
}

void member_declarator(boolean isTypedef) #member_declarator :
{
  String name;
}
{
  name = declarator()
  {
    if (isTypedef) sym.PutTypeName(name);
  }
}
//changed in 1027
void conversion_function_decl_or_def() #conversion_function_decl_or_def :
{
  Scope sc = null;
  String name = null;
}
{
  [
    LOOKAHEAD(scope_override_lookahead())
    name = scope_override()
  ]
  "operator" declaration_specifiers()
  (
    "*"
  | "&"
  )?
  "("
  (
    parameter_list()
  )?
  extern_parameter_list()
  (
    LOOKAHEAD(2)
    type_qualifier()
  )?
  (
    exception_spec()
  )?
  func_decl_def(null) // Temporary (fix the null)
}

void enum_specifier() #enum_specifier :
{
  Token t;
}
{
  "enum"
  (
    "{" enumerator_list() "}"
  | t = < ID >
    (
      LOOKAHEAD(2)
      "{" enumerator_list() "}"
    )?
    {
      sym.PutTypeName(t.image);
    }
  )
}

void enumerator_list() #enumerator_list :
{}
{
  enumerator()
  (
    "," enumerator()
  )*
}

void enumerator() #enumerator :
{}
{
  < ID >
  (
    "=" constant_expression()
  )?
}

void ptr_operator() #ptr_operator :
{}
{
  "&" cv_qualifier_seq()
| "*" cv_qualifier_seq()
| ptr_to_member() cv_qualifier_seq()
}

void cv_qualifier_seq() #cv_qualifier_seq :
{}
{
  [
    LOOKAHEAD(2)
    (
      "const"
      [
        LOOKAHEAD(2)
        "volatile"
      ]
    | "volatile"
      [
        LOOKAHEAD(2)
        "const"
      ]
    )
  ]
}
//changed in 1027
String declarator() #declarator :
{
  String name;
}
{
  (
    LOOKAHEAD((< ID >)* ptr_operator())
    (< ID >)* ptr_operator() name = declarator()
  | name = direct_declarator()
  )
  {
    return name;
  }
}
//changed in 1027
String direct_declarator() #direct_declarator :
{
  String name;
  Token t;
}
{
  LOOKAHEAD(2)
  "~" t = < ID >
  (
    LOOKAHEAD(2)
    declarator_suffixes()
  )?
  {
    return "~" + t.image;
  }
|
{
  System.out.println("direct_declarator(): (declarator())");
} 
"(" name = declarator() ")"
  (
    LOOKAHEAD(2)
    declarator_suffixes()
  )?
  {
    return name;
  }
| name = qualified_id()
  (
    LOOKAHEAD(2)
    declarator_suffixes()
  )?
  {
    return name;
  }
}

void declarator_suffixes() #declarator_suffixes :
{}
{
  (
    "["
    (
      constant_expression()
    )?
    "]"
  )+
| "("
  (
    parameter_list()
  )?
  extern_parameter_list()
  (
    LOOKAHEAD(2)
    type_qualifier()
  )?
  (
    exception_spec()
  )?
}

/**
 * Used only for lookahead.
 */
void function_declarator_lookahead() #function_declarator_lookahead :
{}
{
  (
    LOOKAHEAD(2)
    ptr_operator()
  )*
  qualified_id() "("
}

Scope function_declarator(boolean isTypedef) #function_declarator :
{
  Scope sc = null;
}
{
  (
    LOOKAHEAD(ptr_operator())
    {
      System.out.println("ptr_operator() is true.");
    }
    ptr_operator() sc = function_declarator(isTypedef)
  |
    {
      System.out.println("ptr_operator() is false.");
    }
    sc = function_direct_declarator(isTypedef)
  )
  {
    return sc;
  }
}

Scope function_direct_declarator(boolean isTypedef) #function_direct_declarator :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;
  System.out.println("function_direct_declarator() -- > qualified_id()");
  System.out.println("------------------------function_direct_declarator() "+ getToken(1).image+ "||"+ getToken(2).image+ "||"+ getToken(3).image);
}
{
  name = qualified_id()
  {
    System.out.println("function_direct_declarator():name = qualified_id()= " + name + "==");
    System.out.println("****************function_direct_declarator() -- > GetScopeOfFullyScopeName");
    sc = sym.GetScopeOfFullyScopedName(name);
    if (closeReqd = (sc != null && sc != sym.GetCurScope()))
    {
      System.out.println("function_direct_declarator():closeReqd = (sc != null && sc != sym.GetCurScope())");
      sym.OpenScope(sc);
    }
  }
  "("
  {
    System.out.println("function_direct_declarator() in ( ? ):" + getToken(1).image + getToken(2).image + getToken(3).image);
  }
  (
    {
      System.out.println("function_direct_declarator() -- > parameter_list()");
    }
    parameter_list()
  )?
  extern_parameter_list()
  (
    LOOKAHEAD(2)
    type_qualifier()
  )?
  (
    exception_spec()
  )?
  (
    LOOKAHEAD("=")
    "=" < OCTALINT >
  )?
  (
    function_init()
  )?
  {
    if (closeReqd) sym.CloseScope();
    if (isTypedef) sym.PutTypeName(name);
    return sc;
  }
}
void function_declarator2(boolean isTypedef) #function_declarator2 :
{
}
{
  (
    LOOKAHEAD(ptr_operator())
    {
      System.out.println("ptr_operator() is true.");
    }
    ptr_operator()
    function_declarator2(isTypedef)
  |
    {
      System.out.println("ptr_operator() is false.");
    }
    function_direct_declarator2(isTypedef)
  )
}

void function_direct_declarator2(boolean isTypedef) #function_direct_declarator2 :
{
  String name;
  boolean closeReqd = false;
  System.out.println("function_direct_declarator2() -- > qualified_id()");
  System.out.println("------------------------function_direct_declarator2() "+ getToken(1).image+ "||"+ getToken(2).image+ "||"+ getToken(3).image);
}
{
  name = qualified_id()
  "("
  {
    System.out.println("function_direct_declarator() in ( ? ):" + getToken(1).image + getToken(2).image + getToken(3).image);
  }
  (
    {
      System.out.println("function_direct_declarator() -- > parameter_list()");
    }
    parameter_list()
  )?
  extern_parameter_list()
  (
    LOOKAHEAD(2)
    type_qualifier()
  )?
  (
    exception_spec()
  )?
  (
    LOOKAHEAD("=")
    "=" < OCTALINT >
  )?
}
//deal with-------------- unknow things )
void extern_parameter_list() #extern_parameter_list:
{
  System.out.println("extern_parameter_list().................");
  int kindd;
}
{
  {
    while (getToken(1).kind != RPARENTHESIS)
    {
      kindd = getToken(1).kind;
      jj_consume_token(kindd);
    }
  }
  ")"
}
void function_init() #function_init:
{
  boolean isTypedef = false;
  Scope sc = null;
  System.out.println("void function_init() #function_init:");
}
{
  ":"
  (
    isTypedef = declaration_specifiers()
    (
      LOOKAHEAD(ptr_operator())
      {
        System.out.println("function_init():ptr_operator() is true.");
      }
      ptr_operator() 
      function_declarator2(isTypedef)
    |
      {
        System.out.println("function_init():ptr_operator() is false.");
      }
      function_direct_declarator2(isTypedef)
    )
  |
  (
      LOOKAHEAD(ptr_operator())
      {
        System.out.println("function_init():ptr_operator() is true2.");
      }
      ptr_operator() 
      function_declarator2(false)
    |
      {
        System.out.println("function_init():ptr_operator() is false2.");
      }
      function_direct_declarator2(false)
    )
  )

}
void anytoken() #void:
{
}
{
  (
   <LCURLYBRACE> | <RCURLYBRACE> | <LSQUAREBRACKET> |<RSQUAREBRACKET> |<LPARENTHESIS> |<RPARENTHESIS> |<SCOPE> |<COLON>|<COMMA> |<QUESTIONMARK> |<ELLIPSIS> |<ASSIGNEQUAL> |<TIMESEQUAL> |<DIVIDEEQUAL> |<MODEQUAL> |<PLUSEQUAL> |<MINUSEQUAL> |<SHIFTLEFTEQUAL> |<SHIFTRIGHTEQUAL> |<BITWISEANDEQUAL> |<BITWISEXOREQUAL> |<BITWISEOREQUAL> |<OR_OP> |<AND_OP> |<BITWISEOR> |<BITWISEXOR> |<AMPERSAND> |<EQUAL> |<NOTEQUAL> |<LESSTHAN> |<GREATERTHAN> |<LESSTHANOREQUALTO> |<GREATERTHANOREQUALTO> |<SHIFTLEFT> |<SHIFTRIGHT> |<PLUS> |<MINUS> |<STAR> |<DIVIDE> |<MOD> |<PLUSPLUS> |<MINUSMINUS> |<TILDE> |<NOT_OP> |<DOT> |<POINTERTO> |<DOTSTAR> |<ARROWSTAR> |<AND> |<AND_EQ> |<ASM> |<AUTO> |<BITAND> |<BITOR> |<BOOL> |<BREAK> |<CASE> |<CATCH> |<CHAR> |<CLASS> |<COMPL> |<CONST> |<CONST_CAST> |<CONTINUE> |<_DEFAULT> |<DELETE> |<DO> |<DOUBLE> |<DYNAMIC_CAST> |<ELSE> |<ENUM> |<EXPLICIT> |<EXPORT> |<EXTERN> |<FALSE> |<FLOAT> |<FOR> |<FRIEND> |<GOTO> |<IF> |<INLINE> |<INT> |<LONG> |<mutable> |<NAMESPACE> |<NEW> |<NOT> |<NOT_EQ> |<OPERATOR> |<OR> |<OR_EQ> |<PRIVATE> |<PROTECTED> |<PUBLIC> |<REGISTER> |<REINTERPRET> |<RETURN> |<SHORT> |<SIGNED> |<SIZEOF> |<_STATIC> |<STATIC_CAST> |<STRUCT> |<SWITCH> |<TEMPLATE> |<THIS> |<THROW> |<TRUE> |<TRY> |<TYPEDEF> |<TYPEID> |<TYPENAME> |<UNION> |<UNSIGNED> |<USING> |<VIRTUAL> |<VOID> |<VOLATILE> |<WCHAR_T> |<DWORD> |<WORD> |<BYTE> |<WHILE> |<XOR> |<XOR_EQ> |<OCTALINT> |<OCTALLONG> |<UNSIGNED_OCTALINT> |<UNSIGNED_OCTALLONG> |<DECIMALINT> |<DECIMALLONG> |<UNSIGNED_DECIMALINT> |<UNSIGNED_DECIMALLONG> |<HEXADECIMALINT> |<HEXADECIMALLONG> |<UNSIGNED_HEXADECIMALINT> |<UNSIGNED_HEXADECIMALLONG> |<FLOATONE> |<FLOATTWO> |<CHARACTER> |<STRING> |<ID>
  )
}
void dtor_ctor_decl_spec() #dtor_ctor_decl_spec :
{}
{
  [
    "virtual" [ "inline" ]
  | "inline" [ "virtual" ]
  ]
}

void dtor_definition() #dtor_definition :
{}
{
  (
    template_head()
  )?
  dtor_ctor_decl_spec() dtor_declarator() compound_statement()
}

void ctor_definition() #ctor_definition :
{
  Scope sc = null;
  boolean closeReqd = false;
}
{
  dtor_ctor_decl_spec() sc = ctor_declarator()
  {
    if (closeReqd = (sc != null && sc != sym.GetCurScope())) sym.OpenScope(sc);
  }
  (
    exception_spec()
  )?
  (
    ";"
  | [ ctor_initializer() ] compound_statement()
  )
  {
    if (closeReqd) sym.CloseScope();
  }
}

void ctor_declarator_lookahead() #ctor_declarator_lookahead :
{}
{
  LOOKAHEAD({ IsCtor() })
  qualified_id() "("
}

Scope ctor_declarator() :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;
}
{
  LOOKAHEAD({ IsCtor() })
  name = qualified_id()
  {
    System.out.println("****************ctor_declarator() -- > GetScopeOfFullyScopeName");
    sc = sym.GetScopeOfFullyScopedName(name);
    if (closeReqd = (sc != null && sc != sym.GetCurScope())) sym.OpenScope(sc);
  }
  "("
  [
    LOOKAHEAD(2)
    parameter_list()
  ]
  extern_parameter_list()
  [
    LOOKAHEAD(2)
    exception_spec()
  ]
  {
    if (closeReqd) sym.CloseScope();
    return sc;
  }
}

void ctor_initializer() #ctor_initializer :
{}
{
  ":" superclass_init()
  (
    "," superclass_init()
  )*
}

void superclass_init() #superclass_init :
{}
{
  qualified_id()
  "("
  (
    expression_list()
  )?
  ")"
}

void dtor_declarator() #dtor_declarator :
{}
{
  (
    LOOKAHEAD(scope_override_lookahead())
    scope_override()
  )?
  simple_dtor_declarator()
}

void simple_dtor_declarator() #simple_dtor_declarator :
{}
{
  "~" LOOKAHEAD({ IsCtor() })
  < ID > "("
  (
    parameter_list()
  )?
  extern_parameter_list()
}

void parameter_list() #parameter_list :
{}
{
  parameter_declaration_list()
  [
    LOOKAHEAD(2)
    [ "," ] "..."
  ]
| "..."
}

void parameter_declaration_list() #parameter_declaration_list :
{}
{
  parameter_declaration()
  (
    LOOKAHEAD(2)
    "," parameter_declaration()
  )*
}

void parameter_declaration() #parameter_declaration :
{
  System.out.println("from parameter_list -- > decalration_specifiers()");
  }
{
  declaration_specifiers()
  (
    LOOKAHEAD(declarator())
    declarator()
  | abstract_declarator()
  )
  (
    "=" assignment_expression()
  )?
}

void initializer() #initializer :
{
}
{
  LOOKAHEAD(3)
  {
    System.out.println("initializer() -- > { initializer(),initializer(),...}");
  }
  "{" initializer()
  (
    {
      System.out.println("--------------------------In circle intializer()");
      }
    ","
    [initializer()]
  )*
  "}"
| assignment_expression()
  {
    System.out.println("initializer() -- > assignment_expression()");
  }
}

void type_name() #type_name :
{}
{
  {
    System.out.println("type_name() -- > declaration_specifiers()");
  }
  declaration_specifiers() abstract_declarator()
}

void abstract_declarator() #abstract_declarator :
{}
{
  [
    LOOKAHEAD(2)
    (
      "(" abstract_declarator() ")"
      (
        abstract_declarator_suffix()
      )+
    |
      (
        "["
        (
          constant_expression()
        )?
        "]"
      )+
    | ptr_operator() abstract_declarator()
    )
  ]
}

void abstract_declarator_suffix() #abstract_declarator_suffix :
{}
{
  "["
  (
    constant_expression()
  )?
  "]"
| "("
  (
    parameter_list()
  )?
  extern_parameter_list()
}

void template_head() #template_head :
{}
{
  "template" "<" template_parameter_list() ">"
}

void template_parameter_list() #template_parameter_list :
{}
{
  template_parameter()
  (
    "," template_parameter()
  )*
}

void template_parameter() #template_parameter :
{
  Token t;
}
{
  LOOKAHEAD(3)
  "class" t = < ID >
  {
    sym.PutTypeName(t.image);
  }
| parameter_declaration()
}

void template_id() #template_id :
{}
{
  < ID > "<" template_argument_list() ">"
}

void template_argument_list() #template_argument_list :
{}
{
  template_argument()
  (
    "," template_argument()
  )*
}

void template_argument() #template_argument :
{}
{
  LOOKAHEAD(3)
  type_name()
| shift_expression()
}

void statement_list() #statement_list :
{
  System.out.println("in statement_list -- > statement()");
}
{
  (
    LOOKAHEAD(statement())
    statement()
  )+
}
//changed in 1028 for std::
void statement() #statement :
{
  System.out.println("statement()"+getToken(1).image+getToken(2).image+getToken(3).image);
  }
{
  LOOKAHEAD(2)
  (
    < ID > ":"
  )
  {
    System.out.println("for goto!! in statement()");
  }
| 
  LOOKAHEAD({ getToken(1).kind == __TRY || getToken(1).kind == __ASM || getToken(1).kind == __FINALLY })
  (
    < __TRY >
  | 
    < __ASM >
  | 
    < __FINALLY >
  )
  compound_statement()
| < __EXCEPT >
  (
    (
      "(" expression_list() ")"
    )?
    compound_statement()
  )
| < __LEAVE > ";"
| 
  LOOKAHEAD( (< STD >)< SCOPE >< ID >)
  {
    System.out.println("from statement() to Scope_declaration()");
  }
  Scope_declaration()
| 
  LOOKAHEAD(declaration())
  {
    System.out.println("statement()  -- >  declaration()");
  }
  declaration()
| LOOKAHEAD((< SCOPE >)? expression())
  {
    System.out.println("statement() -- > expression();");
  }
  (< SCOPE >)? expression() ";"
| {
    System.out.println("statement() -- > { compound_statement() }");
  }
  compound_statement()
  
| {
    System.out.println("statement() -- > if (selection_statement()) {...}");
  }
  selection_statement()
  
| {
    System.out.println("statement() -- > jump_statement()(like goto or break)");
  }
  jump_statement()
  
| {
    System.out.println("statement() -- > ;");
  }
  ";"
  
| try_block()
  {
    {
      System.out.println("statement() -- > try_block()");
    }
  }
| throw_statement()
  {
    System.out.println("statement() -- > throw_statement()");
  }
| LOOKAHEAD(2)
  labeled_statement()
  {
    System.out.println("statement() -- > labeled_statement() like <ID>:");
  }
| iteration_statement()
  {
    System.out.println("statement() -- > iteration_statement()");
  }
}

void labeled_statement() #labeled_statement :
{}
{
  < ID > ":" statement()
| "case" constant_expression() ":" statement()
| "default" ":" statement()
}

void compound_statement() #compound_statement :
{
  System.out.println("=====compound_statement=====");
}
{
  "{"
  {
    System.out.println("open a scope in compound_statement");
    sym.OpenScope(null, false);
  }
  (
    {
      System.out.println("compound_statement -- > statement_list");
    }
    statement_list()
  )?
  {
    System.out.println("close a scope in compound_statement");
    sym.CloseScope();
  }
  "}"
}

void selection_statement() #selection_statement :
{}
{
  "if" "("
  (LOOKAHEAD(4)
  	expression()|declarationforif()
  )
  ")" statement()
  (
    LOOKAHEAD(2)
    "else" statement()
  )?
| "switch" "(" expression() ")" statement()
}

void iteration_statement() #iteration_statement :
{}
{
  "while" "(" expression() ")" statement()
| "do" statement() "while" "(" expression() ")" ";"
| "for" "("
  (
    LOOKAHEAD(3)
    declaration()
  | expression() ";"
  | ";"
  )
  (
    expression()
  )?
  ";"
  (
    expression()
  )?
  ")" statement()
}

void jump_statement() #jump_statement :
{}
{
  "goto" < ID > ";"
| "continue" ";"
| "break" ";"
| "return"
  (
    expression()
  )?
  ";"
}

void try_block() #try_block :
{}
{
  < TRY > compound_statement()
  (
    handler()
  )*
}

void handler() #handler :
{}
{
  < CATCH > "(" exception_declaration() ")" compound_statement()
| "finally" compound_statement()
}

void exception_declaration() #exception_declaration :
{}
{
  parameter_declaration_list()
| "..."
}

void throw_statement() #throw_statement :
{}
{
  "throw"
  (
    assignment_expression()
  )?
  ";"
}

void expression() :
{
   System.out.println("expression() ----------------------------");
 }
{
  assignment_expression()
  (
    LOOKAHEAD(2)
    "," assignment_expression()
  )*
}

void assignment_expression() :
{
  System.out.println("assignment_expression()-- > conditional_expression()[=assignment_expression()]");
}
{
  conditional_expression()
  (
    (
      "="
    | "*="
    | "/="
    | "%="
    | "+="
    | "-="
    | "<<="
    | ">>="
    | "&="
    | "^="
    | "|="
    )
    assignment_expression() #assignment_expression(2)
)?
}

void conditional_expression() :
{
  System.out.println("conditional_expression()-- > logical_or_expression()[?xx:xx]");
}
{
  logical_or_expression()
  (
    "?" conditional_expression() ":" conditional_expression() #conditional_expression(3)
)?
}

void constant_expression() :
{}
{
  conditional_expression()
}

void logical_or_expression() :
{
  System.out.println("logical_or_expression() -- > logical_and_expression() { || logical_and_expression()}");
}
{
  logical_and_expression()
  (
    "||" logical_and_expression() #logical_or_expression(2)
)*
}

void logical_and_expression() :
{
  System.out.println("logical_and_expression() -- > inclusive_or_expression(){ && inclusive_or_expression()}");
}
{
  inclusive_or_expression()
  (
    "&&" inclusive_or_expression() #logical_and_expression(2)
)*
}

void inclusive_or_expression() :
{
  System.out.println("inclusive_or_expression()-- > exclusive_or_expression() { | exclusive_or_expression()}");
}
{
  exclusive_or_expression()
  (
    "|" exclusive_or_expression() #inclusive_or_expression(2)
)*
}

void exclusive_or_expression() :
{
  System.out.println("exclusive_or_expression()-- >and_expression() { ^and_expression()}");
}
{
  and_expression()
  (
    "^" and_expression() #exclusive_or_expression(2)
)*
}

void and_expression() :
{
  System.out.println("and_expression() -- > equality_expression(){ & equality_expression()}");
}
{
  equality_expression()
  (
    LOOKAHEAD(2)
    "&" equality_expression() #and_expression(2)
)*
}

void equality_expression() :
{
  System.out.println("equality_expression() -- > relational_expression(){ !=/== relational_expression()}");
}
{
  relational_expression()
  (
    (
      "!="
    | "=="
    )
    relational_expression() #equality_expression(2)
)*
}

void relational_expression() :
{
  System.out.println("relational_expression() -- > shift_expression(){ >/<.. shift_expression()}");
}
{
  shift_expression()
  (
    LOOKAHEAD(2)
    (
      "<"
    | ">"
    | "<="
    | ">="
    )
    shift_expression() #relational_expression(2)
)*
}

void shift_expression() :
{
  System.out.println("shift_expression() -- > additive_expression() { >>/<< additive_expression()}");
}
{
  additive_expression()
  (
    (
      "<<"
    | ">>"
    )
    additive_expression() #shift_expression(2)
)*
}

void additive_expression() :
{
  System.out.println("additive_expression() -- > multiplicative_expression() { +/- multiplicative_expression()}");
}
{
  multiplicative_expression()
  (
    LOOKAHEAD(2)
    (
      "+"
    | "-"
    )
    multiplicative_expression() #additive_expression(2)
)*
}

void multiplicative_expression() :
{
  System.out.println("multiplicative_expression() -- >pm_expression() { /_*_% pm_expression()}");
}
{
  pm_expression()
  (
    LOOKAHEAD(2)
    (
      "*"
    | "/"
    | "%"
    )
    pm_expression() #multiplicative_expression(2)
)*
}

void pm_expression() :
{
  System.out.println("pm_expression() -- > cast_expression() { ./-> cast_expression() }");
}
{
  cast_expression()
  (
    (
      ".*"
    | "->*"
    )
    cast_expression() #pm_expression)*
}

void cast_expression() :
{
//System.out.println("?!cast_expression()?!");
}
{
  LOOKAHEAD("(" type_name() ")")
  {
    System.out.println("cast_expression() -- > (type_name) cast_expression()");
  }
  "(" type_name() ")" cast_expression() #cast_expression(2)
|
{
  System.out.println("cast_expression() -- > unary_expression()");
}
unary_expression()
}

void IncOrDecOperator() #IncOrDecOperator : //++或--运算符(前)
{}
{
  (
    "++"
  | "--"
  )
}

void SizeOfOperator() #SizeOfOperator : //sizeof运算符
{}
{
  < SIZEOF >
  (
    LOOKAHEAD("(" type_name())
    "("
    (
      type_name()
    )
    ")"
    {
      System.out.println("SizeOfOperator() -- > ( type_name() )");
    }
  | unary_expression()
  )
}

void unary_expression() :
{}
{
  IncOrDecOperator() unary_expression() #unary_expression(2)
{
  System.out.println("++/-- prefix!");
}

| LOOKAHEAD(3)
{
  System.out.println("unary_expression() -- > unary_operator() cast_expression()");
}
unary_operator() cast_expression() #unary_expression(2)

|
{
  System.out.println("unary_expression() -- > SizeOfOperator()");
}
SizeOfOperator() #unary_expression(1)
|
{
  System.out.println("unary_expression() -- > postfix_expression()");
}
postfix_expression()
}
//changed in 1028 for new ...
void new_expression() #new_expression :
{}
{
  (
    LOOKAHEAD(< SCOPE >)
    < SCOPE >
  )?
  "new"
  (
    LOOKAHEAD(< ID > ((< SCOPE >)?< ID >)* (< LESSTHAN >|< LPARENTHESIS >)?)
    < ID >
    {
      while(getToken(1).kind != SEMICOLON) {
        jj_consume_token(getToken(1).kind);
      }
       }
    
  | 
    LOOKAHEAD("(" type_name() ")")
    "(" type_name() ")"
  |
    (
      LOOKAHEAD("(" expression_list())
      {
        System.out.println("new_expression()-- >(expression_list())");
      }
      "(" expression_list() ")"
    )?
    (
      LOOKAHEAD("(" type_name() ")")
      "(" type_name() ")"
    | LOOKAHEAD(declaration_specifiers())
      new_type_id()
    )
  )
  (
    LOOKAHEAD(new_initializer())
    new_initializer()
  )?
}

void new_type_id() #new_type_id :
{}
{
  declaration_specifiers()
  (
    LOOKAHEAD(new_declarator())
    new_declarator()
  )?
}

void new_declarator() #new_declarator :
{}
{
  direct_new_declarator()
| ptr_operator() cv_qualifier_seq()
  [
    LOOKAHEAD(2)
    new_declarator()
  ]
}

void direct_new_declarator() #direct_new_declarator :
{}
{
  (
    LOOKAHEAD(2)
    "[" expression() "]"
  )+
}

void new_initializer() #new_initializer :
{
  System.out.println("new_initializer() -- > ([expression_list()])");
}
{
  "("
  (
    expression_list()
  )?
  ")"
}

void delete_expression() #delete_expression :
{}
{
  ("::")? "delete" ("[" "]")? cast_expression()
}

void unary_operator() #unary_operator :
{}
{
  "&"
| "*"
| "+"
| "-"
| "~"
| "!"
}

//protea: just don't know why postfix_expression(2) can make such a big difference
//changed in 1020
void postfix_expression() :
{
  System.out.println("postfix_expression() -- > primary_expression()");
}
{
  LOOKAHEAD(3)
  primary_expression()
  (
    LOOKAHEAD(2)
    (
      "[" expression() "]" #postfix_expression(2)
    {
      System.out.println("postfix_expression() -- > [expression()]");
    }
  | "("
    {
      System.out.println("postfix_expression() -- > (expression_list()?)");
    }
    (
      {
        System.out.println("postfix_expression() -- > expression_list()");
      }
      expression_list()
    )?
    ")" #postfix_expression(1)
| "." id_expression() #postfix_expression(2)
{
  System.out.println("postfix_expression() -- > . + id_expression()");
}

| "->" id_expression() #postfix_expression(2)
{
  System.out.println("postfix_expression() -- > -> + id_expression()");
}

| IncOrDecOperator() #postfix_expression(2)
{
  System.out.println("postfix_expression() -- > -> ++/--");
}

)
)*
|
{
  System.out.println("postfix_expression() -- > simple_type_specifier()");
}

simple_type_specifier() "("
(
  {
    System.out.println("postfix_expression() -- > simple_type_specifier() + expression_list()");
  }
  expression_list()
)?
")"
}

void id_expression() #id_expression :
{
  String name="";
  Token t;
  }
{
  (
    LOOKAHEAD(scope_override_lookahead())
    {
      System.out.println("id_expression() -- > scope_override()");
    }
    name = scope_override()
    {
      System.out.println("id_expression() -- > scope_override() we get the name:"+name);
      } 
  )?
  (
    {
      System.out.println("id_expression()" + tokenImage [ getToken(1).kind ] + getToken(1).image);
    }
    < ID >
  {
    System.out.println("for goto !!!");
  }
  | "operator" optor()
  | "~" < ID >
  )
}
/*void ifdef_expression() #ifdef_expression():
{
  System.out.println("new for ifdef");
}
{
  < _IFDEF >(expression())+
  < _ELSE > (expression())*
  < _ENDIF >
}*/
void primary_expression() #primary_expression :
{}
{
  "this"
|
  (
    LOOKAHEAD(2)
    {
      System.out.println("primary_expression() -- > <STRING>:"+getToken(1).image);
    }
    < STRING >
    
  )+
| 
	"reinterpret_cast"
	{
	  System.out.println("primary_expression() -- >reinterpret_cast");
	  while(getToken(1).kind != SEMICOLON) {
	    jj_consume_token(getToken(1).kind);
	  }
	}
| 
  {
    System.out.println("primary_expression() -- > (expression())");
  }
  "(" expression() ")"
| LOOKAHEAD((extern_builtin_type_specifier())?("::")? "new")
  {
    System.out.println("primary_expression() -- > (new_expression())");
  }
  new_expression()
  
| LOOKAHEAD((extern_builtin_type_specifier())?("::")? "delete")
  delete_expression()
  {
    System.out.println("primary_expression() -- > (delete_expression())");
  }
|
  {
    System.out.println("primary_expression() -- > (id_expression())"+getToken(1).image+getToken(2).image);
  }
  (
    (< SCOPE >)+
  | (< SCOPE >)?
  )
  id_expression()
| constant()
  {
    System.out.println("primary_expression() -- > (constant())");
  }
}

void expression_list() #expression_list :
{
  System.out.println("expression_list() -- > assignment_expression() { ,assignment_expression()}");
}
{
  assignment_expression()
  (
    "," assignment_expression()
  )*
}

void constant() #constant :
{}
{
  < OCTALINT >
| < OCTALLONG >
| < DECIMALINT >
| < DECIMALLONG >
| < HEXADECIMALINT >
| < HEXADECIMALLONG >
| < UNSIGNED_OCTALINT >
| < UNSIGNED_OCTALLONG >
| < UNSIGNED_DECIMALINT >
| < UNSIGNED_DECIMALLONG >
| < UNSIGNED_HEXADECIMALINT >
| < UNSIGNED_HEXADECIMALLONG >
| < CHARACTER >
| < FLOATONE >
| < FLOATTWO >
| "true"
| "false"
}

void optor() #optor :
{}
{
  "new"
  [
    LOOKAHEAD(2)
    "[" "]"
  ]
| "delete"
  [
    LOOKAHEAD(2)
    "[" "]"
  ]
| "+"
| "-"
| "*"
| "/"
| "%"
| "^"
| "&"
| "|"
| "~"
| "!"
| "="
| "<"
| ">"
| "+="
| "-="
| "*="
| "/="
| "%="
| "^="
| "&="
| "|="
| "<<"
| ">>"
| ">>="
| "<<="
| "=="
| "!="
| "<="
| ">="
| "&&"
| "||"
| "++"
| "--"
| ","
| "->*"
| "->"
| "(" ")"
| "[" "]"
| declaration_specifiers()
  (
    LOOKAHEAD(2)
    (
      "*"
    | "&"
    )
  )?
}

void exception_spec() #exception_spec :
{}
{
  "throw" "(" exception_list() ")"
}

void exception_list() #exception_list :
{}
{
  type_name()
  (
    "," type_name()
  )*
}
