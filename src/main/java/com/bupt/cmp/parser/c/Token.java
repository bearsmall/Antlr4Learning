/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.bupt.cmp.parser.c;

/**
 * Describes the input token stream.
 */

public class Token implements java.io.Serializable {

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;

  /** The line number of the first character of this Token. */
  public int beginLine;
  /** The column number of the first character of this Token. */
  public int beginColumn;
  /** The line number of the last character of this Token. */
  public int endLine;
  /** The column number of the last character of this Token. */
  public int endColumn;

  /**
   * The string image of the token.
   */
  public String image;

  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;

  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;

  /**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-null value can
   * override this method as appropriate.
   */
  public Object getValue() {
	  switch(kind){
	  case 0: return "EOF";
	  case 1: return "IN_FORMAL_COMMENT";
	  case 2: return "IN_MULTI_LINE_COMMENT ";
//	  case 3: return "";
//	  case 4: return "";
//	  case 5: return "";
//	  case 6: return "";
//	  case 7: return "";
//	  case 8: return "";
	  case 9: return "SINGLE_LINE_COMMENT";
	  case 10: return "FORMAL_COMMENT";
	  case 11: return "MULTI_LINE_COMMENT";
//	  case 12: return "";
	  case 13: return "ABSTRACT";
	  case 14: return "ASSERT";
	  case 15: return "BOOLEAN";
	  case 16: return "BREAK";
	  case 17: return "BYTE";
	  case 18: return "CASE";
	  case 19: return "CATCH";
	  case 20: return "CHAR";
	  case 21: return "CLASS";
	  case 22: return "CONST";
	  case 23: return "CONTINUE";
	  case 24: return " _DEFAULT";
	  case 25: return "DO";
	  case 26: return "DOUBLE";
	  case 27: return "ELSE";
	  case 28: return "ENUM";
	  case 29: return "EXTENDS";
	  case 30: return "FALSE";
	  case 31: return "FINAL";
	  case 32: return "FINALLY";
	  case 33: return "FLOAT";
	  case 34: return "FOR";
	  case 35: return "GOTO";
	  case 36: return "IF";
	  case 37: return "IMPLEMENTS";
	  case 38: return "IMPORT";
	  case 39: return "INSTANCEOF";
	  case 40: return "INT";
	  case 41: return "INTERFACE";
	  case 42: return "LONG";
	  case 43: return "NATIVE";
	  case 44: return "NEW";
	  case 45: return "NULL";
	  case 46: return "PACKAGE";
	  case 47: return "PRIVATE";
	  case 48: return "PROTECTED";
	  case 49: return "PUBLIC";
	  case 50: return "RETURN";
	  case 51: return "SHORT";
	  case 52: return "STATIC";
	  case 53: return "STRICTFP";
	  case 54: return "SUPER";
	  case 55: return "SWITCH";
	  case 56: return "SYNCHRONIZED";
	  case 57: return "THIS";
	  case 58: return "THROW";
	  case 59: return "THROWS";
	  case 60: return "TRANSIENT";
	  case 61: return "TRUE";
	  case 62: return "TRY";
	  case 63: return "VOID";
	  case 64: return "VOLATILE";
	  case 65: return "WHILE";
	  case 66: return "INTEGER_LITERAL";
	  case 67: return "DECIMAL_LITERAL";
	  case 68: return "HEX_CHAR";
	  case 69: return "HEX_LITERAL";
	  case 70: return "OCTAL_LITERAL";
	  case 71: return "FLOAT_TAIL";
	  case 72: return "FLOATING_POINT_LITERAL";
	  case 73: return "DEC_FLOATING_POINT_LITERAL";
	  case 74: return "HEX_FLOATING_POINT_LITERAL";
	  case 75: return "DEC_EXPONENT";
	  case 76: return "HEX_EXPONENT";
	  case 77: return "CHARACTER_LITERAL";
	  case 78: return "STRING_LITERAL";
	  case 79: return "IDENTIFIER";
	  case 80: return "LETTER";
	  case 81: return "PART_LETTER";
	  case 82: return "LPAREN";
	  case 83: return "RPAREN";
	  case 84: return "LBRACE";
	  case 85: return "RBRACE";
	  case 86: return "LBRACKET";
	  case 87: return "RBRACKET";
	  case 88: return "SEMICOLON";
	  case 89: return "COMMA";
	  case 90: return "DOT";
	  case 91: return "AT";
	  case 92: return "ASSIGN";
	  case 93: return "LT";
	  case 94: return "BANG";
	  case 95: return "TILDE";
	  case 96: return "HOOK";
	  case 97: return "COLON";
	  case 98: return "EQ";
	  case 99: return "LE";
	  case 100: return "GE";
	  case 101: return "NE";
	  case 102: return "SC_OR";
	  case 103: return "SC_AND";
	  case 104: return "INCR";
	  case 105: return "DECR";
	  case 106: return "PLUS";
	  case 107: return "MINUS";
	  case 108: return "STAR";
	  case 109: return "SLASH";
	  case 110: return "BIT_AND";
	  case 111: return "BIT_OR";
	  case 112: return "XOR";
	  case 113: return "REM";
	  case 114: return "LSHIFT";
	  case 115: return "PLUSASSIGN";
	  case 116: return "MINUSASSIGN";
	  case 117: return "STARASSIGN";
	  case 118: return "SLASHASSIGN";
	  case 119: return "ANDASSIGN";
	  case 120: return "ORASSIGN";
	  case 121: return "XORASSIGN";
	  case 122: return "REMASSIGN";
	  case 123: return "LSHIFTASSIGN";
	  case 124: return "RSIGNEDSHIFTASSIGN";
	  case 125: return "RUNSIGNEDSHIFTASSIGN";
	  case 126: return "ELLIPSIS";
	  case 127: return "RUNSIGNEDSHIFT";
	  case 128: return "RSIGNEDSHIFT";
	  case 129: return "GT";
//	  case 130: return "";
	  case 131: return "STUFF_TO_IGNORE";

	  default:return "DEFAULT";
  }
//	switch(kind){
//		case 0:return "EOF";
//		case 7:return "INTEGER_LITERAL";
//		case 8:return "DECIMAL_LITERAL";
//		case 9:return "HEX_LITERAL";
//		case 10:return "OCTAL_LITERAL";
//		case 11:return "FLOATING_POINT_LITERAL";
//		case 12:return "EXPONENT";
//		case 13:return "CHARACTER_LITERAL";
//		case 14:return "STRING_LITERAL";
//		case 15:return "AUTO";
//		case 16:return "REGISTER"; 
//		case 17:return "STATIC";
//		case 18:return "EXTERN";
//		case 19:return "TYPEDEF";
//		case 20:return "VOID";
//		case 21:return "CHAR";
//		case 22:return "SHORT";
//		case 23:return  "INT";
//		case 24:return "LONG";
//		case 25:return "FLOAT";
//		case 26:return "DOUBLE";
//		case 27:return "SIGNED";
//		case 28:return "UNSIGNED";
//		case 29:return "CONST";
//		case 30:return "VOLATILE";
//		case 31:return "CASE";
//		case 32:return "DFLT";
//		case 33:return "IF";
//		case 34:return "ELSE";
//		case 35:return "SWITCH";
//		case 36:return "WHILE";
//		case 37:return "FOR";
//		case 38:return "DO";
//		case 39:return "GOTO";
//		case 40:return "CONTINUE";
//		case 41:return "BREAK";
//		case 42:return "RETURN";
//		case 43:return "IDENTIFIER";
//		case 44:return "LETTER";
//		case 45:return "DIGIT";
//		default:return ""+kind;
//	}
  }

  /**
   * No-argument constructor
   */
  public Token() {}

  /**
   * Constructs a new token for the specified Image.
   */
  public Token(int kind)
  {
    this(kind, null);
  }

  /**
   * Constructs a new token for the specified Image and Kind.
   */
  public Token(int kind, String image)
  {
    this.kind = kind;
    this.image = image;
  }

  /**
   * Returns the image.
   */
  public String toString()
  {
    return image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */
  public static Token newToken(int ofKind, String image)
  {
    switch(ofKind)
    {
      default : return new Token(ofKind, image);
    }
  }

  public static Token newToken(int ofKind)
  {
    return newToken(ofKind, null);
  }

}
/* JavaCC - OriginalChecksum=ac816dfbc87b9e7d3801326b8626b4d0 (do not edit this line) */
