/**
 *
 * Copyright (C) 2000 ITC-irst, Centro per la Ricerca Scientifica
 *                    e Tecnologica, Trento, Italy.
 *
 * Authors: Paolo Tonella and Alessandra Potrich
 * E-mail: {tonella, potrich}@itc.it
 * Date: 30/6/2000
 *
 *
 * Derived in part from the following works:
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 * Author: Sreenivasa Viswanadha
 * Date: 3/20/97
 *
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 *
 */
options
{

  //此选项将代码中的u转义符转换成对应的unicode字符，为了避免出错，先加上此选项，日后可以去掉，并改用预处理的方式实现
  JAVA_UNICODE_ESCAPE = true;
  
  //此选项允许代码中有中文，如果JAVA_UNICODE_ESCAPE设为false，则应该加上该选项
  //UNICODE_INPUT = true;

  //此选项使可以new出任意多个Parser对象
  STATIC = false;

  //不报告错误，可以提高效率
  ERROR_REPORTING = false;

  //自定义工厂类
  //TOKEN_FACTORY = "TokenFactory";

  //缓存token，可以提高效率，但因此不适合交互式使用
  CACHE_TOKENS = true;

  JDK_VERSION = "1.5";
}
PARSER_BEGIN(CPPParser)
package examiner.parser.cpp;
import java.util.ArrayList;
import java.util.List;

import examiner.parser.cpp.ClassScope;
import examiner.parser.cpp.Scope;
import examiner.parser.cpp.SymtabManager;
import examiner.codefile.DefaultCodeFile;
import examiner.pre.LineStruct;

public final class CPPParser {

  private static String vers = "v20";
  private static String id = "C++ Parser";
  private static boolean isFriend = false;
 /**
* 存放token值序列的结构
*/
  private ArrayList<Integer> tokenlist = null;
  /**
	 * 存放token值序列的结构,带行号
	 */
      private List<LineStruct> linetokenlist = null;

  /**
* @return token值序列
*/
  final public ArrayList<Integer> getTokenList() {
          return tokenlist;
  }
  
  final public List<LineStruct> getLineTokenList() {
      return linetokenlist;
}

  /**
* 运行词法解析
*/
  final public void runLexical() throws ParseException {
          tokenlist = new ArrayList<Integer>();
          Token mt = token.next;
          while (mt.kind != CPPParserConstants.EOF) {
                  tokenlist.add(mt.kind);
                  
                  mt = token_source.getNextToken();
          }
  }
  /**
   * 运行词法分析，按行返回Token的哈希值
   * @throws ParseException
   */
  final public void runLineLexical(DefaultCodeFile cf) throws ParseException {
      linetokenlist = cf.getTokenLine();
      linetokenlist.clear();
      Token mt = getToken(1);
      int hashValue=0;
      int tempHashValue=0;
      int tempLineNum=0;
      String LineString = new String();
      while (mt.kind != CPPParserConstants.EOF) {
      	    tempLineNum=mt.beginLine;
      	    while(mt.beginLine==tempLineNum&&mt.kind != CPPParserConstants.EOF){
      	    	LineString=LineString+" "+mt.getValue();
      	    	mt = token_source.getNextToken();
      	    	//System.out.println(mt.kind+" "+mt.image);
      	    }
      	    
      
      	    hashValue=LineString.hashCode();
      	    //System.out.println(LineString+" "+hashValue);
      	    if(hashValue!=tempHashValue){//只对与上一行hash值不同的行进行记录
          		LineStruct temp=new LineStruct();
          		temp.setLineNum(tempLineNum);
          		temp.setHashValue(hashValue);
          		linetokenlist.add(temp);
          		tempHashValue=hashValue;
          		
      	    }
      	    LineString="";
              
             
      }
//      cf.setTokenLine(linetokenlist);
}
  private static void msg(String s) {
      System.out.println(id + " Version " + vers +": " + s);
  }

  public static void main(String args[]) {
    CPPParser parser;
    java.io.InputStream input;

    int ai = 0;

    if (ai == (args.length-1)) {
      msg("Reading from file " + args[ai] + " . . .");
      try {
        input = new java.io.FileInputStream(args[ai]);
      } catch (java.io.FileNotFoundException e) {
        msg("File " + args[0] + " not found.");
        return;
      }
    } else if (ai >= args.length) {
      msg("Reading from standard input . . .");
      input = System.in;
    } else {
      msg("Usage: java " + id + " [-d] [inputfile]");
      return;
    }

    try {
      parser = new CPPParser(input);
      parser.translation_unit();
      msg("Program parsed successfully.");
    } catch (ParseException e) {
      msg(e.getMessage());
    }
  }

  /**
   * A symbol table manager object. Currently only types are recorded for
   * doing semantic predicates for parsing.
   */
  static SymtabManager sym;


  /**
   * Utility method used to skip template arguments.
   * It must be invoked with the token index of the first angular bracket.
   * It returns the token index after the last angular bracket.
   */
  int SkipTemplateArgument(int i)
  {
     Token t = getToken(i);
     if (t.kind != LESSTHAN)
        return i;

     int initial_i = i;
     int angularBrackets = 1;	
     int parentheses = 0;
     int braces = 0;

     while (angularBrackets > 0) {
	t = getToken(++i);
	if (t.kind == EOF)
	   return initial_i;
        if (parentheses < 0 || braces < 0) 
	   return initial_i; 
	if (t.kind == LESSTHAN)
	   angularBrackets++;
	if (t.kind == GREATERTHAN)
	   angularBrackets--;
	if (t.kind == LPARENTHESIS)
	   parentheses++;
	if (t.kind == RPARENTHESIS)
	   parentheses--;
	if (t.kind == LCURLYBRACE)
	   braces++;
	if (t.kind == RCURLYBRACE)
	   braces--;
     }	
     return i+1;
  }

  /*
   * Methods used in semantics predicates.
   */

  /**
   * Reads a fully qualified name (since it is used during lookahead, we 
   * cannot use token. We have to explicitly use getToken).
   */
  String GetFullyScopedName()
  {
     int i = 1;
     Token t = getToken(i);

     if (t.kind == TILDE) {
        i++;
        t = getToken(i);
     }
     if (t.kind != ID && t.kind != SCOPE)
        return null;

     StringBuffer s = new StringBuffer();

     if (t.kind != SCOPE)
     {
        s.append(t.image);
	i++;
	i = SkipTemplateArgument(i);
        t = getToken(i++);
     }
     else 
        i++;

     while (t.kind == SCOPE)
     {
        s.append(t.image);
	t = getToken(i++);
        if (t.kind == TILDE)
          t = getToken(i++);
        s.append(t.image);
	i = SkipTemplateArgument(i);
        t = getToken(i++);
     }

     return s.toString();
  }

  /**
   * This method first tries to read a sequence of tokens of the form 
   *             ("::")? <ID> ("::" <ID>)* 
   * and if it succeeds then asks the symbol table manager  if this is
   * the name of a constructor.
   */
  final boolean IsCtor()
  {
      return sym.IsCtor(GetFullyScopedName());
  }

  /**
   * Reads a fully qualified name (since it is used during lookahead, we 
   * cannot use token. We have to explicitly use getToken), followed by 
   * the first type name of the parameter list.
   */
  final String GetMethodNameAndInitialSignature()
  {
     StringBuffer s = new StringBuffer();
     int i = 1 ,j;
     Token t = getToken(i++);

     // reads first method name then type name
     for (j = 1 ; j <= 2 ; j++) { 
	 if (t.kind != ID && t.kind != SCOPE)
	     return null;

	 if (t.kind != SCOPE) {
	     s.append(t.image);
	     t = getToken(i++);
	 }
	 while (t.kind == SCOPE || t.kind == LESSTHAN) {
             if (t.kind == LESSTHAN) {
                while (t.kind != GREATERTHAN)
                  t = getToken(i++);
                t = getToken(i++);
	     }

	     s.append(t.image);
	     s.append((t = getToken(i++)).image);
	     t = getToken(i++);
	 }
	 if (j == 2)
	     break;
	 if (t.kind != LPARENTHESIS)
	     return null;
	 s.append("(");
	 t = getToken(i++);
     }

     return s.toString();
  }

  /**
   * This method first tries to read a sequence of tokens of the form 
   *             ("::")? <ID> ("::" <ID>)* "(" ("::")? <ID> ("::" <ID>)* 
   * If it succeeds it checks if the string after the left parenthesis is 
   * a known type.
   */
  boolean IsMethod()
  {
     return sym.IsMethod(GetMethodNameAndInitialSignature());
  }
}

PARSER_END(CPPParser)

TOKEN_MGR_DECLS :
{
   static int beginLine;
   static int beginCol;
   static boolean lineDirective = false;

   static void resetBeginLineCol()
   {
   }
}

SKIP :
{
  " "
|
  "\t"
|
  "\n"
|
  "//" : IN_LINE_COMMENT
|
  "/*" : IN_COMMENT
|
  < "#" ([" ", "\t"])* "line" > : LINE_NUMBER
|
  < "#" ([" ", "\t"])* ["0"-"9"] > { input_stream.backup(1); } : LINE_NUMBER
|
  "#" : PREPROCESSOR_OUTPUT
}

<LINE_NUMBER> SKIP:
{
   < (["0"-"9"])+ >
   {
     try
     {
        beginLine = Integer.parseInt(image.toString());
     }
     catch(NumberFormatException e) { } // Will never come here.
   } : LINE_DIRECTIVE
}

<LINE_DIRECTIVE> SKIP:
{
  "\n" : AFTER_LINE_DIRECTIVE
|
  <~[]>
}

<AFTER_LINE_DIRECTIVE> SKIP:
{
      
  <~[]>
  {
     input_stream.adjustBeginLineColumn(beginLine, 1);
     input_stream.backup(1);
  } : DEFAULT
}

<IN_LINE_COMMENT> SKIP:
{
   "\n" : DEFAULT
}

<IN_LINE_COMMENT> MORE:
{
  < ~[] >
}

<IN_COMMENT> SKIP:
{
   "*/" : DEFAULT
}

<IN_COMMENT> MORE:
{
  < ~[] >
}

<PREPROCESSOR_OUTPUT> SKIP:
{
   "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
  < ~[] >
}

TOKEN :
{
  < LCURLYBRACE: "{" >
| < RCURLYBRACE: "}" >
| < LSQUAREBRACKET: "[" >
| < RSQUAREBRACKET: "]" >
| < LPARENTHESIS: "(" >
| < RPARENTHESIS: ")" >
| < SCOPE: "::" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < QUESTIONMARK: "?" >
| < ELLIPSIS: "..." >
| < ASSIGNEQUAL: "=" >
| < TIMESEQUAL: "*=" >
| < DIVIDEEQUAL: "/=" >
| < MODEQUAL: "%=" >
| < PLUSEQUAL: "+=" >
| < MINUSEQUAL: "-=" >
| < SHIFTLEFTEQUAL: "<<=" >
| < SHIFTRIGHTEQUAL: ">>=" >
| < BITWISEANDEQUAL: "&=" >
| < BITWISEXOREQUAL: "^=" >
| < BITWISEOREQUAL: "|=" >
| < OR: "||" >
| < AND: "&&" >
| < BITWISEOR: "|" >
| < BITWISEXOR: "^" >
| < AMPERSAND: "&" >
| < EQUAL: "==" >
| < NOTEQUAL: "!=" >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < LESSTHANOREQUALTO: "<=" >
| < GREATERTHANOREQUALTO: ">=" >
| < SHIFTLEFT: "<<" >
| < SHIFTRIGHT: ">>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < DIVIDE: "/" >
| < MOD: "%" >
| < PLUSPLUS: "++" >
| < MINUSMINUS: "--" >
| < TILDE: "~" >
| < NOT: "!" >
| < DOT: "." >
| < POINTERTO: "->" >
| < DOTSTAR: ".*" >
| < ARROWSTAR: "->*" >
| < AUTO: "auto" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DELETE: "delete" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTERN: "extern" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FRIEND: "friend" >
| < GOTO: "goto" >
| < IF: "if" >
| < INLINE: "inline" >
| < MUTABLE: "mutable" >
| < EXPLICIT: "explicit" >
| < DYNAMIC_CAST: "dynamic_cast" >
| < STATIC_CAST: "static_cast" >
| < REINTERPRET_CAST: "reinterpret_cast" >
| < CONST_CAST: "const_cast" >
| < TYPEID: "typeid" >
| < WCHAR_T: "wchar_t" >
| < BOOL: "bool" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < REDECLARED: "redeclared" >
| < REGISTER: "register" >
| < RETURN: "return" >
| < SHORT: "short" >
| < SIGNED: "signed" >
| < SIZEOF: "sizeof" >
| < STATIC: "static" >
| < STRUCT: "struct" >
| < CLASS : "class" >
| < TYPENAME : "typename" >
| < SWITCH: "switch" >
| < TEMPLATE: "template" >
| < EXPORT: "export" >
| < THIS: "this" >
| < TRY: "try" >
| < TYPEDEF: "typedef" >
| < UNION: "union" >
| < UNSIGNED: "unsigned" >
| < VIRTUAL: "virtual" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < OPERATOR: "operator" >
| < TRUETOK: "true" >
| < FALSETOK: "false" >
| < THROW: "throw" >
| < BOOLEAN: ("true" | "false") >
}

TOKEN [IGNORE_CASE] :
{
  <  OCTALINT : "0" (["0"-"7"])* >
| <  OCTALLONG : <OCTALINT> "l" >
| <  UNSIGNED_OCTALINT : <OCTALINT> "u" >
| <  UNSIGNED_OCTALLONG : <OCTALINT> ("ul" | "lu") >

| <  DECIMALINT : ["1"-"9"] (["0"-"9"])* >
| <  DECIMALLONG : <DECIMALINT> ["u","l"] >
| <  UNSIGNED_DECIMALINT : <DECIMALINT> "u" >
| <  UNSIGNED_DECIMALLONG : <DECIMALINT> ("ul" | "lu") >

| <  HEXADECIMALINT : "0x" (["0"-"9","a"-"f"])+ >
| <  HEXADECIMALLONG : <HEXADECIMALINT> (["u","l"])? >
| <  UNSIGNED_HEXADECIMALINT : <HEXADECIMALINT> "u" >
| <  UNSIGNED_HEXADECIMALLONG : <HEXADECIMALINT> ("ul" | "lu") >


| <  FLOATONE : ((["0"-"9"])+ "." (["0"-"9"])* | (["0"-"9"])* "." (["0"-"9"])+)
              ("e" (["-","+"])? (["0"-"9"])+)? (["f","l"])? >

| <  FLOATTWO : (["0"-"9"])+ "e" (["-","+"])?  (["0"-"9"])+ (["f","l"])? >
}

TOKEN :
{

  <  CHARACTER : ("L")? "'"
   (   (~["'","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )*
   "'" >

| <  STRING : ("L")? "\""
   ( ( ~["\"","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )*
   "\"" >
}

void translation_unit() :
{
  Scope sc;
}
{
   { 
     sym.OpenScope(null, false, false); 
     sc = sym.GetCurScope();
     sc.PutTypeName("std", sc);
   }
   ( LOOKAHEAD(2) external_declaration() )* <EOF>
   { sym.CloseScope(); }
}

void external_declaration() :
{ 
  boolean isTypedef = false; 
  StringBuffer typedefSource = new StringBuffer();
}
{
    LOOKAHEAD(("typedef" | template_head())? class_head()  "{")
       ( template_head() )? declaration()
   |
    LOOKAHEAD("enum" (<ID>)? "{")
       enum_specifier() (init_declarator_list(false, null))?  ";"
   |
    LOOKAHEAD (dtor_ctor_decl_spec() dtor_declarator_lookahead())
       dtor_definition()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
       ctor_definition()

   |
    LOOKAHEAD((declaration_specifiers(null))?  function_declarator_lookahead())
       function_definition()

   |
    LOOKAHEAD(("inline"| "virtual"| "explicit")* (scope_override())? "operator")
         conversion_function_decl_or_def()
   |
    LOOKAHEAD(3) (template_head())+
      (
        LOOKAHEAD(dtor_ctor_decl_spec() dtor_declarator_lookahead())
           dtor_definition()
      |
        LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
           ctor_definition()
      |
        LOOKAHEAD((declaration_specifiers(null))?  
                   function_declarator_lookahead())
           function_definition()
      |
        LOOKAHEAD(declaration_specifiers(null))
        isTypedef = declaration_specifiers(typedefSource)
               (init_declarator_list(isTypedef, typedefSource))?  ";"
      |
        LOOKAHEAD(("inline"| "virtual"| "explicit")* (scope_override())? 
                   "operator")
         conversion_function_decl_or_def()
      )
   |
    LOOKAHEAD(2) explicit_instantiation()
   |
    explicit_specialization()
   |
    LOOKAHEAD(3) namespace_definition()
   |
    declaration() 
   |
    ";" { sym.ClearSuspendedVarName(); }
}

void function_definition() :
{
   Scope sc = null;
   boolean isTypedef;
}
{
  
    LOOKAHEAD(3) isTypedef = declaration_specifiers(null)
        sc = function_declarator(isTypedef) 
    ("," sc = function_declarator(isTypedef))* func_decl_def(sc)
   |
    sc = function_declarator(false) 
    ("," sc = function_declarator(false))* func_decl_def(sc)
}

void func_decl_def(Scope sc) :
{
   boolean closeReqd = false;
}
{
  {
     if (closeReqd = (sc != null && sc != sym.GetCurScope()))
        sym.OpenScope(sc);
  }

  (
    ";" { sym.ClearSuspendedVarName(); }
   |
    compound_statement()
   |
    "try" compound_statement() (handler())+
  )

  { if (closeReqd) sym.CloseScope(); }
}

void linkage_specification() :
{}
{
   "extern" <STRING>
   (
    "{" ( external_declaration() )* "}" 
      ( LOOKAHEAD(";") ";")?
   |
    external_declaration()
   )
}

void declaration_in_condition() :
{}
{
   declaration_specifiers(null) declarator() "=" initializer()
}

void declaration() :
{ 
  boolean isTypedef = false; 
  StringBuffer typedefSource = new StringBuffer();
}
{
    LOOKAHEAD(2)
      isTypedef = declaration_specifiers(typedefSource)
               (init_declarator_list(isTypedef, typedefSource))? 
                  (";" | compound_statement())
   |
    linkage_specification()
   |
    namespace_alias_definition()
   |
    LOOKAHEAD(2) using_declaration()
   |
    using_directive()
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean type_modifiers() :
{ boolean isTypedef = false; }
{
   (
     isTypedef = storage_class_specifier()
    |
     type_qualifier()
    |
     "inline"
    |
     "explicit"
    |
     "virtual"
    |
     "friend"
      {isFriend = true;}
   )

   { return isTypedef; }
}

/**
 * Returns true if it sees a typedef. Parameter typedefSource stores the 
 * type being aliased.
 */
boolean declaration_specifiers(StringBuffer typedefSource) :
{
   Token t;
   boolean isTypedef = false, tmp;
}
{
   ( LOOKAHEAD(type_modifiers()) tmp = type_modifiers() { isTypedef |= tmp; } )*

   (  builtin_type_specifier()
         ( LOOKAHEAD(2) (
            LOOKAHEAD(builtin_type_specifier()) builtin_type_specifier()
          |
            tmp = type_modifiers() { isTypedef |= tmp; } )
         )*

     |
      LOOKAHEAD(class_head() "{") class_specifier(typedefSource)
     |
      LOOKAHEAD(3) enum_specifier()
     |
      elaborated_type_specifier(typedefSource)
     |
      qualified_type(typedefSource)
   )
   (LOOKAHEAD(2) tmp = type_modifiers() { isTypedef |= tmp; } )*

   {
	isFriend = false;
	return isTypedef; 
   }
}

void type_id() :
{}
{
   (type_specifier())+ (abstract_declarator())
}

void elaborated_type_id() :
{}
{
   (elaborated_type_specifier(null))+ (abstract_declarator())
}

void type_specifier() :
{}
{
    simple_type_specifier()
   |
    class_specifier(null)
   |
    enum_specifier()
}


void simple_type_specifier() :
{}
{
   (
    builtin_type_specifier()
   |
    qualified_type(null)
   )
}

void scope_override_lookahead() :
{}
{
    "::"
   |
    <ID> ("<" (template_argument_list())? ">")? "::"
}

String scope_override() :
{
   String name = "";
   Token t;
}
{
  (
    ("::")  { name += "::"; }
    (
      LOOKAHEAD(scope_override_lookahead()) 
      t = <ID> ("<" (template_argument_list())? ">")? "::"
      { name += t.image + "::"; }
    )*
   |
    (
      LOOKAHEAD(scope_override_lookahead()) 
      t = <ID> ("<" (template_argument_list())? ">")? "::"
      { name += t.image + "::"; }
    )+
  )
  { return name; }
}


String qualified_id() :
{
   String name = "";
   Token t;
}
{
    [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]
    (
      t = <ID> [ LOOKAHEAD(2) "<" (template_argument_list())?  ">" ]
      { return name + t.image; }
     |
      "operator" optor() [ LOOKAHEAD(2) "<" (template_argument_list())?  ">" ]
      { return name + "operator"; }
    )
}

String dtor_qualified_id() :
{
   String name = "";
   Token t;
}
{
    [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]
      "~" t = <ID> [ "<" (template_argument_list())?  ">" ]
      { return name + t.image; }
}

void ptr_to_member() :
{}
{
    scope_override()  "*"
}

void qualified_type(StringBuffer typedefSource) :
{
  String idName;
}
{
    LOOKAHEAD({ sym.IsFullyScopedTypeName(GetFullyScopedName()) } )
        idName = qualified_id()
        { 
           if (typedefSource != null)
              typedefSource.append(idName); 
        }
}

void type_qualifier() :
{}
{
    "const" | "volatile"
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean storage_class_specifier() :
{}
{
   ( "auto" | "register" | "static" | "extern" | "mutable") { return false; }
   | "typedef"  { return true; }
}

void builtin_type_specifier() :
{}
{
   "void" | "char" | "short" | "int" | "long" | "float" |
   "double" | "signed" | "unsigned" | "wchar_t" | "bool"
}

void init_declarator_list(boolean isTypedef, StringBuffer typedefSource) :
{}
{
   init_declarator(isTypedef, typedefSource) 
   ("," init_declarator(isTypedef, typedefSource))* 
}

void init_declarator(boolean isTypedef, StringBuffer typedefSource) :
{ 
   String name; 
   Scope sc;
}
{
   name = declarator()
   {
      if (isTypedef) {
         sym.PutTypeName(name);
         if (typedefSource != null && typedefSource.length() > 0) {
            sc = sym.GetScopeOfFullyScopedName(typedefSource + "::");
	    if (sc != null)
               sym.GetCurScope().PutTypeName(name, sc);            
         }
      } else {
         sc = sym.GetCurScope();
         if (name.indexOf("::") == -1)
	    sc.PutVarName(name);
      }
   }
   (
    "=" initializer()
   |
    "(" expression_list()  ")"
   )?
}

void class_head() :
{}
{
   ("struct" | "union" | "class")
   [ LOOKAHEAD(scope_override_lookahead()) scope_override() ]
   (<ID> (LOOKAHEAD(2) "<" (template_argument_list())?  ">")?
   (base_clause(null))?)?
}

void class_specifier(StringBuffer typedefSource) :
{
   ClassScope csc = null;
   Scope sc = null;
   Token t;
   String name = "";
   boolean nestedScope = false;
}
{
   ("struct" | "union" | "class" )
   (
    "{"
        {
           sym.OpenScope(null, false, false);
        }
        (member_declaration())*
    "}"
        {
           sym.CloseScope();
        }
   |
    LOOKAHEAD(qualified_id()) 
    [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]
     t = <ID> (LOOKAHEAD(2) "<" (template_argument_list())?  ">")?
     {
        sc = sym.GetScopeOfFullyScopedName(name);
	if (sc != null) {
           sym.OpenScope(sc);
	   nestedScope = true;
	}
        sym.PutTypeName(t.image);
        csc = (ClassScope)sym.OpenScope(t.image, true, false);
        if (typedefSource != null)
           typedefSource.append(t.image); 
     }
     (base_clause(csc))? 
    "{"
      (member_declaration())*
    "}"
        {
           sym.CloseScope();
	   if (nestedScope)
	       sym.CloseScope();
        }
   )
}

void namespace_definition() :
{
   Scope sc = null;
   Token t;
}
{
   "namespace"
   (
    "{"
        {
           sym.OpenScope(null, false, true);
        }
        (external_declaration())*
    "}"
        {
           sym.CloseScope();
        }
   |
    LOOKAHEAD(2) t = <ID> 
    "{"
        {
	   sc = sym.GetScope(t.image);
           if (sc != null)
	      sym.OpenScope(sc);
           else
              sc = (ClassScope)sym.OpenScope(t.image, true, true);
        }
        (external_declaration())*
    "}"
        {
           sym.CloseScope();
        }
   )
}

void namespace_alias_definition() :
{   
   Token t;
   String name;
   Scope sc;
}
{
   "namespace" t = <ID> "=" name = qualified_id() ";"
   {
      sc = sym.GetScopeOfFullyScopedName(name + "::");
      sym.GetCurScope().PutTypeName(t.image, sc);
   }
}

void using_declaration() :
{
   String name; 
   boolean isTypename = false;
   Scope sc;
}
{
   "using" ["typename" {isTypename = true;} ] name = qualified_id() ";"
   {
      if (isTypename || sym.IsFullyScopedTypeName(name)) {
	sc = sym.GetScopeOfFullyScopedName(name + "::");
        if (name.indexOf("::") != -1)
	   name = name.substring(name.lastIndexOf("::") + 2, name.length());
	if (sc != null)
           sym.GetCurScope().PutTypeName(name, sc);
        else
           sym.PutTypeName(name);
      }
   }
}

void using_directive() :
{ 
  Scope sc;
  String name; 
}
{
   "using" "namespace" name = qualified_id() ";"
   {
      sc = sym.GetCurScope();
      sc.AddNamespace(sym.GetScopeOfFullyScopedName(name + "::"));
   }
}

void base_clause(ClassScope scope) :
{}
{
   ":" base_specifier(scope) ( "," base_specifier(scope) )*
}

void base_specifier(ClassScope scope) :
{ Token t; }
{
   ("virtual" (access_specifier())? | access_specifier() ("virtual")?)?
   (LOOKAHEAD(scope_override_lookahead()) scope_override())?
   t = <ID> ("<" (template_argument_list())?  ">")?
   {
      scope.AddSuper(sym.GetScope(t.image));
   }
}

void access_specifier() :
{}
{
   "public" | "protected" | "private"
}

void member_declaration() :
{ 
  boolean isTypedef = false; 
  StringBuffer typedefSource = new StringBuffer();
}
{
  LOOKAHEAD(2)
  (LOOKAHEAD(3) template_head())? (
    LOOKAHEAD(("typedef")? class_head() "{") declaration() 
   |
    LOOKAHEAD("enum" (<ID>)? "{") enum_specifier()
       ( member_declarator_list(false, null) )?  ";"
   |
    LOOKAHEAD(("inline"| "virtual"| "explicit")* (scope_override())? "operator")
       conversion_function_decl_or_def()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() dtor_declarator_lookahead())
       dtor_definition()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
       ctor_definition()
   |
    LOOKAHEAD((declaration_specifiers(null))? function_declarator_lookahead())
       function_definition()
   |
    LOOKAHEAD(declaration_specifiers(null))
       isTypedef = declaration_specifiers(typedefSource)
           (member_declarator_list(isTypedef, typedefSource))? 
       { sym.ClearSuspendedVarName(); } (";" | compound_statement())
   |
    LOOKAHEAD(<ID>) function_declarator(false) ";" 
    { sym.ClearSuspendedVarName(); }
   |
    using_declaration()
  )
   |
    LOOKAHEAD(3)
     qualified_id() ";"
   |
    access_specifier()  ":"
   |
    ";" { sym.ClearSuspendedVarName(); }
}

void member_declarator_list(boolean isTypedef, StringBuffer typedefSource) :
{}
{
   member_declarator(isTypedef, typedefSource) ("=" <OCTALINT>)?
   ("," member_declarator(isTypedef, typedefSource) ("=" <OCTALINT>)?)*
}

void member_declarator(boolean isTypedef, StringBuffer typedefSource) :
{ 
   String name; 
   Scope sc;
}
{
   LOOKAHEAD(2) (<ID>)? ":" constant_expression()
  |
   name = declarator()
   {
      if (isTypedef) {
         sym.PutTypeName(name);
         if (typedefSource != null && typedefSource.length() > 0) {
            sc = sym.GetScopeOfFullyScopedName(typedefSource + "::");
	    if (sc != null)
               sym.GetCurScope().PutTypeName(name, sc);            
         }
      } else {
         sc = sym.GetCurScope();
         if (name.indexOf("::") == -1)
	    sc.PutVarName(name);
      }
   }
   ( LOOKAHEAD(2) "=" constant_expression() )?
}

void conversion_function_decl_or_def() :
{
   Scope sc = null;
   String name = null;
}
{
   ( LOOKAHEAD(type_modifiers()) type_modifiers() {isFriend = false;})*
   [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]

   "operator" declaration_specifiers(null) ("*" | "&")?

   "(" (parameter_list())? ")"
   (LOOKAHEAD(2) type_qualifier())? 
   (exception_spec())?
   func_decl_def(null)  // Temporary (fix the null)
}

void enum_specifier() :
{ Token t; }
{  
   "enum"
   (
    "{" enumerator_list() "}"
   |
    t=<ID> (LOOKAHEAD(2) "{" enumerator_list() "}")?
           { sym.PutTypeName(t.image); }
   )
}

void elaborated_type_specifier(StringBuffer typedefSource) :
{ 
  String name; 
  Scope sc = null;
  boolean closeReqd = false;
  String newName = "";
}
{  
   ("enum" | "class" | "struct" | "union" | "typename")
    name = qualified_id() 
    { 
	if (isFriend == true) 
	   name = "::"+name;

        if (typedefSource != null)
           typedefSource.append(name); 	

        sc = sym.GetScopeOfFullyScopedName(name);
        if (closeReqd = (sc != null && sc != sym.GetCurScope()))
           sym.OpenScope(sc);

	if (name.lastIndexOf("::") != -1)
	  name = name.substring(name.lastIndexOf("::") + 2);

	sym.PutTypeName(name);
        if (closeReqd) 
           sym.CloseScope();
    }
}

void enumerator_list() :
{}
{
   enumerator() (LOOKAHEAD(2) "," enumerator())* (",")?
}

void enumerator() :
{}
{
   <ID> ("=" constant_expression())?
}

void ptr_operator() :
{}
{
    "&" cv_qualifier_seq()
   |
    "*" cv_qualifier_seq()
   |
    ptr_to_member() cv_qualifier_seq()
}

void cv_qualifier_seq() :
{}
{
   [ LOOKAHEAD(2) (
     "const" [ LOOKAHEAD(2) "volatile" ]
    |
     "volatile" [ LOOKAHEAD(2) "const" ] )
   ]
}

String declarator() :
{ String name; }
{
  (
    LOOKAHEAD(ptr_operator())
      ptr_operator() name = declarator()
   |
    name = direct_declarator()
  )

  { return name; }
}

String direct_declarator() :
{
   String name;
   Token t;
}
{
   LOOKAHEAD(2)
    "~" t = <ID> (LOOKAHEAD(2) declarator_suffixes())?
        { return "~" + t.image; }
   |
    "(" name = declarator() ")" (LOOKAHEAD(2) declarator_suffixes())?
        { return name; }
   |
    name = qualified_id() (LOOKAHEAD(5) declarator_suffixes())?
    { return name; }
}

void declarator_suffixes() :
{}
{
    ("[" (constant_expression())? "]" )+
   |
    "(" (parameter_list())? ")"
    (LOOKAHEAD(2) type_qualifier())?
    (exception_spec())?
}

/**
 * Used only for lookahead.
 */
void function_declarator_lookahead() :
{}
{
  (LOOKAHEAD(2) ptr_operator() )* 
    ( (qualified_id() "(" (")" |  parameter_list())) |
      LOOKAHEAD( { IsMethod() } ) qualified_id() "(" )
}

Scope function_declarator(boolean isTypedef) :
{ Scope sc = null; }
{
  (
    LOOKAHEAD(ptr_operator())
       ptr_operator() sc = function_declarator(isTypedef)
   |
     sc = function_direct_declarator(isTypedef)
  )

  { return sc; }
}

Scope function_direct_declarator(boolean isTypedef) :
{
  String name; 
  Scope sc = null;
  boolean closeReqd = false;
}
{
     name = qualified_id()

     {
	if (name.indexOf("::") != -1) {
           sc = sym.GetScopeOfFullyScopedName(name);
           if (closeReqd = (sc != null && sc != sym.GetCurScope()))
              sym.OpenScope(sc);  
        }
     }

     "(" (parameter_list())?  ")"
     (LOOKAHEAD(2) type_qualifier())?
     (exception_spec())?
     (LOOKAHEAD("=") "=" <OCTALINT>)?     

     {
        if (closeReqd)
           sym.CloseScope();

        if (isTypedef)
           sym.PutTypeName(name);

        return sc;
     }
}

void dtor_ctor_decl_spec() :
{}
{
   ("virtual" | "inline" | "explicit" | "friend")*
}

void dtor_definition() :
{
  Scope sc = null;
  boolean closeReqd = false;
}
{
   dtor_ctor_decl_spec() sc = dtor_declarator() ("=" <OCTALINT>)?

    {
	if (closeReqd = (sc != null && sc != sym.GetCurScope()))
	   sym.OpenScope(sc);   
    }

   (exception_spec())?
   
   (
     ";" { sym.ClearSuspendedVarName(); }
    |
     "try" compound_statement() (handler())+
    |
     compound_statement()
   )

   { if (closeReqd) sym.CloseScope(); }
}

void ctor_definition() :
{
   Scope sc = null;
   boolean closeReqd = false;
}
{
   dtor_ctor_decl_spec() sc = ctor_declarator()

   {
      if (closeReqd = (sc != null && sc != sym.GetCurScope()))
         sym.OpenScope(sc);   
   }

   (exception_spec())?
   
   (
     ";" { sym.ClearSuspendedVarName(); }
    |
     [ ctor_initializer() ] compound_statement()
    |
     "try" [ ctor_initializer() ] compound_statement() (handler())+
   )

   { if (closeReqd) sym.CloseScope(); }
}

void ctor_declarator_lookahead() :
{}
{
   LOOKAHEAD( { IsCtor() } ) qualified_id() "("
}

void dtor_declarator_lookahead() :
{}
{
   LOOKAHEAD( { IsCtor() } ) dtor_qualified_id() "("
}

Scope ctor_declarator() :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;          
}
{
   LOOKAHEAD( { IsCtor() } )
      name = qualified_id()
 
     {
        sc = sym.GetScopeOfFullyScopedName(name);
 
        if (closeReqd = (sc != null && sc != sym.GetCurScope()))
           sym.OpenScope(sc);         
     }
                                      
     "(" [ LOOKAHEAD(2) parameter_list() ]  ")"

     [ LOOKAHEAD(2) exception_spec() ]
      
     {
        if (closeReqd)
           sym.CloseScope();          
 
        return sc;                    
     }
}

Scope dtor_declarator() :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;          
}
{
   LOOKAHEAD( { IsCtor() } )
      name = dtor_qualified_id()
 
     {
        sc = sym.GetScopeOfFullyScopedName(name);
 
        if (closeReqd = (sc != null && sc != sym.GetCurScope()))
           sym.OpenScope(sc);         
     }
                                      
     "(" [ LOOKAHEAD(2) parameter_list() ]  ")"

     [ LOOKAHEAD(2) exception_spec() ]
      
     {
        if (closeReqd)
           sym.CloseScope();          
 
        return sc;                    
     }
}

void ctor_initializer() :
{}
{
   ":" superclass_init() ("," superclass_init())*
}

void superclass_init() :
{}
{
   qualified_id()  "(" (expression_list())?  ")"
}

void parameter_list() :
{}
{
    parameter_declaration_list() [ LOOKAHEAD(2) [ "," ] "..." ]
   |
    "..."
}

void parameter_declaration_list() :
{}
{
   parameter_declaration() (LOOKAHEAD(2) "," parameter_declaration())*
}

void parameter_declaration() :
{   
   String name; 
}
{
   declaration_specifiers(null)
   (
    LOOKAHEAD(declarator()) name = declarator() 
    {
       if (name.indexOf("::") == -1)
	  sym.AddSuspendedVarName(name);
    }

   |
    abstract_declarator()
   )
   ("=" assignment_expression())?
}

void initializer() :
{}
{
    LOOKAHEAD(3)
     "{" initializer() (LOOKAHEAD(2) "," initializer())* (",")? "}"
   |
    assignment_expression()
}

void type_name() :
{}
{
   declaration_specifiers(null) abstract_declarator()
}

void abstract_declarator() :
{}
{
   [ LOOKAHEAD(2) (
    "(" abstract_declarator()   ")"
    (abstract_declarator_suffix())+
   |
    ("[" (expression())? "]")+
   |
    ptr_operator() abstract_declarator() )
   ]
}

void abstract_declarator_suffix() :
{}
{
    "[" ( expression() )?  "]"
   |
    "(" (parameter_list())? ")"
    cv_qualifier_seq()
}

void template_head() :
{}
{
   ("export")? "template" "<" (template_parameter_list())? ">"
}

void template_parameter_list() :
{}
{
   template_parameter() ("," template_parameter())*
}

void template_parameter() :
{ Token t; }
{
    LOOKAHEAD(3)
    ("class" | "typename") t = <ID> 
    { sym.PutTypeName(t.image); } 
      [ "=" (LOOKAHEAD(3) type_id() | elaborated_type_id())]
   |
    parameter_declaration()
}

void template_id() :
{}
{
   <ID> "<" (template_argument_list())? ">"
}

void template_argument_list() :
{}
{
   template_argument() ("," template_argument())*
}

void template_argument() :
{}
{
    LOOKAHEAD(3)
      type_name()
   |
    shift_expression()
   ( 
     LOOKAHEAD(2)
     ( 
         "<="
       | ">="
     )
     shift_expression()
   )*
}

void explicit_instantiation() :
{}
{
   "template" declaration()
}

void explicit_specialization() :
{}
{
   "template" "<" ">" declaration()
}

void statement_list() :
{}
{  
   (LOOKAHEAD(statement()) statement())+
}

void statement() :
{}
{
    LOOKAHEAD( declaration() )
      declaration()
   |
    LOOKAHEAD( expression() ";" )
      expression() ";"
   |
    compound_statement()
   |
    selection_statement()
   |
    jump_statement()
   |
    ";"
   |
    try_block()
   |
    LOOKAHEAD(2)
      labeled_statement()
   |
    iteration_statement()
}

void labeled_statement() :
{}
{
    <ID> ":" statement()
   |
    "case" constant_expression()  ":" statement()
   |
    "default"  ":" statement()
}

void compound_statement() :
{}
{
   "{"

   { 
     sym.OpenScope(null, false, false); 
     sym.PutSuspendedVarName();
     sym.ClearSuspendedVarName();
   }

   (statement_list())?

   { sym.CloseScope(); }

   "}"
}

void selection_statement() :
{}
{
    "if" "(" (LOOKAHEAD(declaration_in_condition()) 
        declaration_in_condition() | expression()) ")" 
     statement()
     (LOOKAHEAD(2) "else" statement())?
   |
    "switch" "(" (LOOKAHEAD(declaration_in_condition()) 
        declaration_in_condition() | expression()) ")" 
     statement()
}

void iteration_statement() :
{}
{
    "while" "(" (LOOKAHEAD(declaration_in_condition()) 
        declaration_in_condition() | expression()) ")" 
     statement()
   |
    "do" statement() 
    "while" "(" (LOOKAHEAD(declaration_in_condition()) 
        declaration_in_condition() | expression()) ")" 
     ";"
   |
    "for" "(" (LOOKAHEAD(3) declaration() | expression() ";" | ";")
    (expression())? ";" (expression())? ")" statement()
}

void jump_statement() :
{}
{
    "goto" <ID> ";"
   |
    "continue" ";"
   |
    "break" ";"
   |
    "return" (expression())? ";"
}

void try_block() :
{}
{
   "try" compound_statement() (handler())+
}

void handler() :
{}
{
   "catch" "(" exception_declaration() ")"
   compound_statement()
 |
   "finally" compound_statement()
}

void exception_declaration() :
{}
{    parameter_declaration_list()
   |
     "..."
}

void throw_expression() :
{}
{    
   "throw" (LOOKAHEAD(2) assignment_expression())?
}

void expression() :
{}
{
   assignment_expression() ( LOOKAHEAD(2) "," assignment_expression())*
}

void assignment_expression() :
{}
{
  ( conditional_expression()
    (("="
   | "*="
   | "/="
   | "%="
   | "+="
   | "-="
   | "<<="
   | ">>="
   | "&="
   | "^="
   | "|="
   )
   assignment_expression()
   )? ) |
   throw_expression()
}

void conditional_expression() :
{}
{   logical_or_expression()
   ("?" expression()  ":" conditional_expression())?
}

void constant_expression() :
{}
{    conditional_expression()
}

void logical_or_expression() :
{}
{    logical_and_expression() ( "||" logical_and_expression())*
}

void logical_and_expression() :
{}
{    inclusive_or_expression() ( "&&" inclusive_or_expression())*
}

void inclusive_or_expression() :
{}
{    exclusive_or_expression()( "|" exclusive_or_expression())*
}

void exclusive_or_expression() :
{}
{    and_expression()( "^" and_expression())*
}

void and_expression() :
{}
{    equality_expression()( LOOKAHEAD(2) "&" equality_expression())*
}

void equality_expression() :
{}
{    relational_expression()(( "!=" | "==") relational_expression())*
}

void relational_expression() :
{}
{  shift_expression()
   ( 
     LOOKAHEAD(2)
     ( 
         "<"
       | ">"
       | "<="
       | ">="
     )
     shift_expression()
   )*
}

void shift_expression() :
{}
{    additive_expression()(( "<<" | ">>") additive_expression())*
}

void additive_expression() :
{}
{    multiplicative_expression()
   (LOOKAHEAD(2) ( "+" | "-") multiplicative_expression())*
}

void multiplicative_expression() :
{}
{  pm_expression()
   (LOOKAHEAD(2) ( "*" | "/" | "%") pm_expression())*
}

void pm_expression() :
{}
{
    cast_expression() (( ".*" | "->*" ) cast_expression())*
}

void cast_expression() :
{}
{  
    LOOKAHEAD( "(" type_name() ")")
     "(" type_name() ")" cast_expression()
   |
     unary_expression()    
}

void unary_expression() :
{}
{  
     "++" cast_expression()
   |
     "--" cast_expression()
   |
     LOOKAHEAD(3)
     unary_operator() cast_expression()
   |
     "sizeof"
     ( 
       LOOKAHEAD("(" type_name()  ")")
       "(" type_name()  ")"
     |
       unary_expression()
     )
   |
     postfix_expression()
}

void new_expression() :
{}
{    
   (LOOKAHEAD("::") ("::"))?
   "new"
   (
     LOOKAHEAD("(" type_name() ")" )
      "(" type_name() ")" 
    |
     (LOOKAHEAD("(" expression_list() ) "(" expression_list() ")")?
     (
       LOOKAHEAD("(" type_name() ")" )
       "(" type_name() ")" 
      |
       LOOKAHEAD(declaration_specifiers(null))
        new_type_id()
     )
   )
   (LOOKAHEAD(new_initializer()) new_initializer())?
}

void new_type_id() :
{}
{
   declaration_specifiers(null)  
   ( LOOKAHEAD(new_declarator()) new_declarator() )?
}

void new_declarator() :
{}
{ 
     direct_new_declarator()
   |
     ptr_operator() cv_qualifier_seq()  [ LOOKAHEAD(2) new_declarator() ]
}

void direct_new_declarator() :
{}
{
   (LOOKAHEAD(2) "[" expression() "]" )+
}

void new_initializer() :
{}
{    "(" ( expression_list() )? ")"
}

void delete_expression() :
{}
{    ( "::" )? "delete" ( "[" "]" )? cast_expression()
}

void unary_operator() :
{}
{    "&"
   | "*"
   | "+"
   | "-"
   | "~"
   | "!"
}

void postfix_expression() :
{}
{  
   LOOKAHEAD(3)
    (
      primary_expression() 
     | 
      "dynamic_cast" "<" [ type_qualifier() ] type_id() ">" 
     | 
      "static_cast" "<" [ type_qualifier() ] type_id() ">" 
     | 
      "reinterpret_cast" "<" [ type_qualifier() ] type_id() ">" 
     | 
     "const_cast" "<" [ type_qualifier() ] type_id() ">" 
     | 
      "typeid" "(" (LOOKAHEAD(3) [ type_qualifier() ] type_id() | 
                  expression_list()) ")"
    )
    ( LOOKAHEAD(2) (
       "[" expression() "]"
      |
       "(" ( expression_list() )? ")"
      |
       "." id_expression()
      |
       "->" id_expression()
      |
       "++"
      |
       "--" )
    )*
  | 
   simple_type_specifier() "(" ( expression_list() )? ")"
}

void id_expression() :
{}
{   
   (LOOKAHEAD(scope_override_lookahead()) scope_override())?
   (LOOKAHEAD(template_id()) template_id()
   | "operator" optor()
   | "~"  <ID>
   | <ID>
   )
}

void primary_expression() :
{}
{  
     "this"
   | ( LOOKAHEAD(2) <STRING> )+
   | "(" expression()  ")"
   |
     LOOKAHEAD( ("::")? "new")
     new_expression()
   |
     LOOKAHEAD( ("::")? "delete")
     delete_expression()
   | id_expression()
   | constant()
}

void expression_list() :
{}
{    assignment_expression()( "," assignment_expression())*
}

void constant() :
{}
{    <OCTALINT>
   | <OCTALLONG>
   | <DECIMALINT>
   | <DECIMALLONG>
   | <HEXADECIMALINT>
   | <HEXADECIMALLONG>

   | <BOOLEAN>

   | <UNSIGNED_OCTALINT>
   | <UNSIGNED_OCTALLONG>
   | <UNSIGNED_DECIMALINT>
   | <UNSIGNED_DECIMALLONG>
   | <UNSIGNED_HEXADECIMALINT>
   | <UNSIGNED_HEXADECIMALLONG>

   | <CHARACTER>
   | <FLOATONE>
   | <FLOATTWO>
   | "true"
   | "false"
}

void optor() :
{}
{
     "new" [ LOOKAHEAD(2) "[" "]" ]
   | "delete" [ LOOKAHEAD(2) "[" "]" ]
   | "+"
   | "-"
   | "*"
   | "/"
   | "%"
   | "^"
   | "&"
   | "|"
   | "~"
   | "!"
   | "="
   | "<"
   | ">"
   | "+="
   | "-="
   | "*="
   | "/="
   | "%="
   | "^="
   | "&="
   | "|="
   | "<<"
   | ">>" 
   | ">>="
   | "<<="
   | "=="
   | "!="
   | "<="
   | ">="
   | "&&"
   | "||"
   | "++"
   | "--"
   | ","
   | "->*"
   | "->"
   | "(" ")"
   | "[" "]"
   | declaration_specifiers(null) (LOOKAHEAD(2) ("*"|"&"))?
}

void exception_spec() :
{}
{
   "throw" "(" (exception_list())? ")"
}

void exception_list() :
{}
{
   type_name() ( "," type_name())*
}

TOKEN :
{
  <  ID : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
}


/*end*/
